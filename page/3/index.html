<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiazx.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Try Everything......">
<meta property="og:type" content="website">
<meta property="og:title" content="J Blog">
<meta property="og:url" content="http://jiazx.top/page/3/index.html">
<meta property="og:site_name" content="J Blog">
<meta property="og:description" content="Try Everything......">
<meta property="og:locale">
<meta property="article:author" content="Stephen Jia">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiazx.top/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>J Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">J Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/mysql-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/mysql-1/" class="post-title-link" itemprop="url">MySQL进阶及优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:20:33 / Geändert am: 17:20:49" itemprop="dateCreated datePublished" datetime="2020-08-16T17:20:33+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、MySQL常用存储引擎"><a href="#一、MySQL常用存储引擎" class="headerlink" title="一、MySQL常用存储引擎"></a>一、MySQL常用存储引擎</h1><p>进入mysql<br>show engines;<br><img src="https://img-blog.csdnimg.cn/20200229105025677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>常用的mysql引擎主要有两种，一种是InnoDB（mysql默认），另一种是MyISAM.<br>显示所有引擎之后从引擎的注释中可以发现，<strong>InnoDB是支持事务和外键的并且使用行级锁</strong>。而MyISAM不支持事务。</p>
<p>除此之外，两个引擎的其他区别如下表：<br><img src="https://img-blog.csdnimg.cn/20200229105558879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="二、MySQL索引"><a href="#二、MySQL索引" class="headerlink" title="二、MySQL索引"></a>二、MySQL索引</h1><h2 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h2><p>首先：用到索引的字段一定是经常用来查询的字段：<br>例如有一user表有四个字段：<br>id  name  email   phone<br>经常用的查询语句如下:<br>select * from user where name = ‘xxx’;<br>那么就可以在经常用于查询的字段name上面建立索引：<br><strong>create index idx_user_name on user(name);</strong><br>上面的索引属于单值索引，在执行上面的查询语句的时候就可以加快查询速度。</p>
<h2 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h2><p>其实通俗的讲，复合索引就是一张表内的多个索引<br>还是上面的user表，假设经常用的查询语句如下<br>select * from user where name = ‘xxx’ and email= ‘xxx@xx.com’;<br>经常用name和email一起作为查询条件，此时就可以建立复合索引<br><strong>create index idx_user_nameEmail on user(name, email);</strong></p>
<h2 id="join语句"><a href="#join语句" class="headerlink" title="join语句"></a>join语句</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvNDU0OTMvMjAxOTA0LzQ1NDkzLTIwMTkwNDIwMTQzMDM1MjU3LTYyNDY3NTc2NS5wbmc?x-oss-process=image/format,png" alt="在这里插入图片描述"></p>
<h2 id="索引概念和b-树"><a href="#索引概念和b-树" class="headerlink" title="索引概念和b+树"></a>索引概念和b+树</h2><p>索引是帮助mysql高效获取数据的<strong>数据结构</strong><br>可以简单理解为“排好序的快速查找<strong>数据结构</strong>”<br>总结：索引的本质是<strong>数据结构</strong>！<br>索引一般是存储在硬盘当中的，而不是内存中。</p>
<p>所以，索引可以提高<br>select …where （加索引的字段）;<br>……order by(加索引的字段);<br>这两类语句的速度和性能</p>
<p>一般来说，MySQL默认的索引的数据结构为b+树索引，b+树和b树有类似的地方，他们的叶子结点都在同一层，且都是平衡树。<br>关于b+树索引的详细介绍可以看这篇文章：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26222859/article/details/80631121![%E5%9C%A8%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tcC5zb2h1LmNvbS91cGxvYWQvMjAxNzA3MTMvZDhhZTFiMTRlOWJmNGIxODkwMTQ2ZWI4MDNlZTk3OTVfdGgucG5n?x-oss-process=image/format,png)">https://blog.csdn.net/qq_26222859/article/details/80631121![在这里插入图片描述](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5tcC5zb2h1LmNvbS91cGxvYWQvMjAxNzA3MTMvZDhhZTFiMTRlOWJmNGIxODkwMTQ2ZWI4MDNlZTk3OTVfdGgucG5n?x-oss-process=image/format,png)</a></p>
<p>简单来说，b+树叶子节点是连起来的，而且所有的数据都存储在叶子节点，中间的结点不存储数据。</p>
<p>所以，b+树对于b树的优点在于：<br>1.中间结点不存放数据，<strong>减少了磁盘的io次数</strong>。<br>2.b+树的<strong>查找是稳定的</strong>，b树的查找可能会时快时慢，所以b+树性能稳定。<br>3.因为b+树的叶子节点都是连接的，所以大大<strong>简化了范围查询</strong>的流程，但是对于b树来说，还需要复杂的中序遍历来找到对应的范围。</p>
<p>总结：</p>
<p>B+树的特征：<br>1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。<br>2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。<br>3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。</p>
<p>B+树的优势：<br>1.单一节点存储更多的元素，使得查询的IO次数更少。<br>2.所有查询都要查找到叶子节点，查询性能稳定。<br>3.所有叶子节点形成有序链表，便于范围查询。</p>
<h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><p>优点：<br>1.提高数据检索效率<br>2.降低数据库io成本<br>3.降低数据排序的成本，降低排序时cpu的消耗</p>
<p>缺点：<br>1.最大的缺点是增删改操作效率会降低，因为进行update操作的时候，不仅要保存数据，而且还要维护正常的索引指向，且保存索引文件中更新的部分。<br>2.索引文件会占用磁盘空间</p>
<h2 id="索引的增删改查"><a href="#索引的增删改查" class="headerlink" title="索引的增删改查"></a>索引的增删改查</h2><p>增：<br>create index <strong>indexName</strong> on <strong>tableName(cloumn1, column2, ……)</strong>;</p>
<p>删：<br>drop index <strong>indexName</strong> on <strong>tableName</strong>;</p>
<p>改：<br>alter <strong>tableName</strong> add index <strong>indexName</strong> on <strong>(cloumn1, column2, ……)</strong>;</p>
<p>查：<br>show index from tableName\G;</p>
<h1 id="三、建立索引的场景"><a href="#三、建立索引的场景" class="headerlink" title="三、建立索引的场景"></a>三、建立索引的场景</h1><h2 id="适合建立索引的场景"><a href="#适合建立索引的场景" class="headerlink" title="适合建立索引的场景"></a>适合建立索引的场景</h2><p>1.主键自动建立唯一索引<br>2.频繁作为查询字段的索引<br>5.当既可以用单值索引，又可以用组合索引时，倾向于组合索引<br>6.查询中需要排序的字段适合建立索引<br>7.查询中统计或者分组的字段适合建立索引</p>
<h2 id="不适合建立索引的场景"><a href="#不适合建立索引的场景" class="headerlink" title="不适合建立索引的场景"></a>不适合建立索引的场景</h2><p>1.频繁更新的字段<strong>不适合建立索引</strong><br>2.where条件中用不到的字段不用创建索引<br>3.字段内容大量重复的字段不要建立索引</p>
<h1 id="四、MySQL性能分析explain"><a href="#四、MySQL性能分析explain" class="headerlink" title="四、MySQL性能分析explain"></a>四、MySQL性能分析explain</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。<br>类似于一个sql语句的<strong>化验报告单</strong><br>使用：<br>explain + sql    即把explain关键字加在sql语句前面</p>
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>可以查看以下内容：</p>
<ul>
<li>表的读取顺序</li>
<li>数据读取操作的数据类型</li>
<li>哪些索引可以使用</li>
<li>哪些索引实际被使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>例如，我这里查询一个user信息表<br><img src="https://img-blog.csdnimg.cn/20200229160730723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>分析如下的查询语句：<br><img src="https://img-blog.csdnimg.cn/20200229160822279.png" alt="在这里插入图片描述"><br>下面逐列的介绍这几个字段的含义。</p>
<h2 id="id：表的操作顺序"><a href="#id：表的操作顺序" class="headerlink" title="id：表的操作顺序"></a>id：表的操作顺序</h2><p>select查询的序列号，包含一组数字，表示查询中执行select或字句或操作表的顺序。</p>
<p>例子一：<br><img src="https://img-blog.csdnimg.cn/20200229162158458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里因为where条件中有个and，and之后的条件先被判断，所以先执行了t1表的查询，然后是and前面的t3表，最后t2表。因为三张表没有子查询存在，所以id都是相同的，下面是id不同的子查询例子。<br>例子二：<br><img src="https://img-blog.csdnimg.cn/20200229162307199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>因为有子查询的存在，所以mysql会先进入<strong>最内部一层</strong>的子查询表内查询，所以id不同，执行顺序也不同，是<strong>从下往上的</strong>。<strong>id越大越先执行</strong>。这里的t1，t3的select_tyep也表明了是子查询。</p>
<p><img src="https://img-blog.csdnimg.cn/20200229163327116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这张表id有不同的有相同的，规则还是不变，id不同的时候，id大的先执行；id相同的时候，从上到下执行。<br>注意第三列中的derived2的意思是，这个是id=2的表(即t3)的衍生表。（对应上面sql语句里面的s1）。</p>
<p>总结：id相同：按顺序执行；id不同：id大的先执行。</p>
<h2 id="select-type-查询语句的属性"><a href="#select-type-查询语句的属性" class="headerlink" title="select_type:查询语句的属性"></a>select_type:查询语句的属性</h2><p><img src="https://img-blog.csdnimg.cn/20200229175348485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="type-查询操作的性能体现"><a href="#type-查询操作的性能体现" class="headerlink" title="type:查询操作的性能体现"></a>type:查询操作的性能体现</h2><p><img src="https://img-blog.csdnimg.cn/20200229180123878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上到小<br>system：表只有一行记录（几乎不出现）<br>const：表示通过索引一次就找到了<br>eq_ref:唯一性索引扫描，每个索引键对应一条 记录<br>ref：非唯一性索引扫描，每个索引键对应非唯一的记录<br>range：只检索给定范围的行<br>index：全索引扫描<br>all：全表扫描</p>
<h2 id="possible-keys和keys"><a href="#possible-keys和keys" class="headerlink" title="possible keys和keys"></a>possible keys和keys</h2><p>possible keys：显示可能应用在这张表中的索引，一个或多个<br>查询涉及到的字段上若存在索引则该索引将被列出，但不一定被查询实际使用。</p>
<p>keys：实际使使用到的索引<br>若出现覆盖索引（覆盖索引就是查询的字段和顺序和索引的字段和顺序完全一样）则该索引只出现在keys中</p>
<h2 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h2><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精度的情况下，长度越短越好。<br>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>显示索引的那一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<h2 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h2><p>每张表有多少行被优化器查询</p>
<h1 id="五、索引优化"><a href="#五、索引优化" class="headerlink" title="五、索引优化"></a>五、索引优化</h1><p>以下内容源于<a target="_blank" rel="noopener" href="https://cyc2018.github.io/CS-Notes/#/notes/MySQL">https://cyc2018.github.io/CS-Notes/#/notes/MySQL</a></p>
<p>1.独立的列<br>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p>
<p>例如下面的查询不能使用 actor_id 列的索引：<br>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</p>
<p>2.多列索引<br>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p>
<p>SELECT film_id, actor_ id FROM sakila.film_actor<br>WHERE actor_id = 1 AND film_id = 1;</p>
<p>3.索引列的顺序<br>让选择性最强的索引列放在前面。</p>
<p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p>
<p>SELECT COUNT(DISTINCT staff_id)/COUNT(<em>) AS staff_id_selectivity,<br>COUNT(DISTINCT customer_id)/COUNT(</em>) AS customer_id_selectivity,<br>COUNT(<em>)<br>FROM payment;<br>Copy to clipboardErrorCopied<br>staff_id_selectivity: 0.0001<br>customer_id_selectivity: 0.0373<br>               COUNT(</em>): 16049<br>4. 前缀索引<br>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p>
<p>前缀长度的选取需要根据索引选择性来确定。</p>
<p>5.覆盖索引<br>索引包含所有需要查询的字段的值。</p>
<p>具有以下优点：</p>
<p>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。<br>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。<br>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</p>
<h1 id="六、主从复制和读写分离"><a href="#六、主从复制和读写分离" class="headerlink" title="六、主从复制和读写分离"></a>六、主从复制和读写分离</h1><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p>读写分离能提高性能的原因在于：</p>
<p><strong>主从服务器负责各自的读和写，极大程度缓解了锁的争用</strong>；<br><strong>从服务器可以使用 MyISAM</strong>，提升查询性能以及节约系统开销；<br>增加冗余，提高可用性。<br>读写分离常用代理方式来实现，<strong>代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</strong>。<br><img src="https://img-blog.csdnimg.cn/20200229200006670.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a><strong>主从复制</strong></h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p>
<p>binlog 线程 ：负责将主服务器上的<strong>数据更改写入二进制日志</strong>（Binary log）中。<br>I/O 线程 ：负责从主服务器上<strong>读取二进制日志</strong>，并写入从服务器的<strong>中继日志</strong>（Relay log）。<br>SQL 线程 ：负责<strong>读取中继日志</strong>，<strong>解析出主服务器已经执行的数据更改并在从服务器中重放</strong>（Replay）。<br><img src="https://img-blog.csdnimg.cn/20200229195929489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><h2 id="mysql-limit关键字的两个参数分别是什么？"><a href="#mysql-limit关键字的两个参数分别是什么？" class="headerlink" title="mysql limit关键字的两个参数分别是什么？"></a>mysql limit关键字的两个参数分别是什么？</h2><p>不要理解为开始的行和结束的行！这是错误的理解。<br>正确的两个参数是<br>1：开始显示的行<br>2：要显示的行数<br>比如要做一个分页功能。每一页显示五条记录。<br>那么就是select * from item limit x, 5;<br>x为前台传参获得，比如用户点击第五页，那么第五页显示的就是21-25这五条记录，那么就将(5-1) * 5传给即可。</p>
<h2 id="行锁，表锁都是啥？"><a href="#行锁，表锁都是啥？" class="headerlink" title="行锁，表锁都是啥？"></a>行锁，表锁都是啥？</h2><p>行锁：只锁一行，并发度较高。<br>表锁：锁整个表，并发度较低。所以MyISAM引擎不适合频繁写操作。适合大量读的操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/jvm-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/jvm-3/" class="post-title-link" itemprop="url">JVM学习笔记三：JVM堆内存调优（初步）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:19:01 / Geändert am: 17:19:58" itemprop="dateCreated datePublished" datetime="2020-08-16T17:19:01+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ul>
<li>永久代大小</li>
</ul>
<p>在Java8中，永久代已经被移除，被一个称为元空间的区域所取代。元空间的本质和永久代类似。<br>元空间与永久代之间最大的区别在于：<br>永久带使用的JVM的堆内存，但是java8以后的元空间并不在虚拟机中而是<strong>使用本机物理内存</strong>。<br>因此，默认情况下，<strong>元空间的大小仅受本地内存限制</strong>。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。 </p>
<p>java7<br>-XX:PermSize：永久代空间<br>-XX:MaxPermSize：最大永久代空间<br><img src="https://img-blog.csdnimg.cn/20200210160324228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>java8<br><img src="https://img-blog.csdnimg.cn/20200210160334714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>最常用的三个参数：<br><img src="https://img-blog.csdnimg.cn/20200210160554365.png" alt="在这里插入图片描述"><br>默认的情况下，jvm分配的内存是总内存的“<strong>1 / 4</strong>”、而初始化的内存为“<strong>1 / 64</strong>”<br>在idea中，可以通过Run Configurations里面的VM arguments设置一个或多个参数：<br><img src="https://img-blog.csdnimg.cn/20200210160857902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一般来说，初始内存和最大内存要设置成相等的值。防止jvm内存不稳定。<br>若将jvm内存设置很小，就容易造成OOM：heap space的错误<br>如：设置VM参数：-Xms8m -Xmx8m -XX:+PrintGCDetails<br>写一个死循环一直生成大对象，gc回收跟不上new对象的速度。<br>String str = “hello” ;<br>while(true)<br>{<br>str += str + new Random().nextInt(88888888) + new Random().nextInt(999999999) ;<br>}<br><img src="https://img-blog.csdnimg.cn/20200210170429861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/jvm-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/jvm-2/" class="post-title-link" itemprop="url">JVM学习笔记二：JVM堆</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:18:44 / Geändert am: 17:19:52" itemprop="dateCreated datePublished" datetime="2020-08-16T17:18:44+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>堆内存的大小是可以调节的。类加载器读取了类文件后，需要把类、方法、常变量放到堆内存中，<strong>保存所有引用类型的真实信息</strong>，以方便执行器执行，堆内存分为三部分：</p>
<ul>
<li>新生区 young</li>
<li>老年区 old</li>
<li>永久区 perm</li>
</ul>
<p>下图是更加详细的分区：<br><img src="https://img-blog.csdnimg.cn/2020021011190751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h1 id="新生区-young"><a href="#新生区-young" class="headerlink" title="新生区 young"></a>新生区 young</h1><h2 id="新生区概述："><a href="#新生区概述：" class="headerlink" title="新生区概述："></a>新生区概述：</h2><p>新生区当中包括<strong>eden区，from区和to区</strong>（from和to即两个幸存者区）<br>因为young区的GC为复制算法，所以有两块from和to区域，当有一次minorGC没有将伊甸区的对象回收时。此对象被放到from区。若此对象下一次minorGC仍没有被回收，<strong>他将会和从伊甸区新来的幸存对象一起放到to区，此时from和to区互换身份，如此往复</strong>，。所以说幸存者1区和2区的角色是交替的，并不固定。当15次minorGC之后对象仍没有被回收，他就将进入到old区(由JVM参数MaxTenuringThreshold决定,这个参数默认是15)，同时，如果两个幸存者区都满了，幸存的对象也会移动到养老区，若养老区执行了Full GC之后发现依然无法进行对象的保存，就会产生OOM异常“OutOfMemoryError”。</p>
<ul>
<li>tips：如果出现<code>java.lang.OutOfMemoryError</code>: Java heap space异常，说明Java虚拟机的堆内存不够。原因有二：<br>（1）Java虚拟机的堆内存设置不够，可以通过参数**-Xms、-Xmx**来调整。<br>（2）代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）。</li>
</ul>
<h2 id="新生区-minorGC："><a href="#新生区-minorGC：" class="headerlink" title="新生区 minorGC："></a>新生区 minorGC：</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>新生区使用的GC是minorGC，他是通过复制算法实现的。<br>Minor GC会把Eden中的所有活的对象都移到Survivor区域中，如果Survivor区中放不下，那么剩下的活的对象就被移到Old  generation中，<strong>也即一旦收集后，Eden是就变成空的了</strong>。<br>  当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用<strong>复制算法</strong>将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，通过-XX:MaxTenuringThreshold 来设定参数)，这些对象就会成为老年代。</p>
<p><strong>-XX:MaxTenuringThreshold</strong> —— 设置对象在新生代中存活的次数</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ul>
<li>复制算法的优点是不会产生内存碎片。</li>
<li>复制算法它的缺点也是相当明显的。<br>　　1、它浪费了一半的内存，<strong>这是最突出的缺点</strong>。<br>　　2、如果对象的存活率非常高，那么复制大量引用的成本也会很高。</li>
</ul>
<h1 id="老年区-old"><a href="#老年区-old" class="headerlink" title="老年区 old"></a>老年区 old</h1><h2 id="老年区概述："><a href="#老年区概述：" class="headerlink" title="老年区概述："></a>老年区概述：</h2><p>新生代的对象年龄默认达到<strong>15</strong>时，进入老年代。<br>新生区和老年区的比例一般为<strong>一比二</strong>。新生区占三分之一，老年区占三分之二。因为绝大部分对象都是临时对象，<br>新生区的eden区和from区，to区的比例为：<strong>8:1:1</strong>。<br><img src="https://img-blog.csdnimg.cn/20200210114652163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200210115444110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="老年区-GC"><a href="#老年区-GC" class="headerlink" title="老年区 GC:"></a>老年区 GC:</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>全局GC（<strong>major GC or Full GC</strong>）：指发生在老年代的垃圾收集动作，出现了Major GC，<strong>经常会伴随至少一次的Minor GC</strong>（但并不是绝对的）。Major GC的速度一般要比Minor GC慢上10倍以上 。</p>
<h3 id="fullGC之一：标记清除："><a href="#fullGC之一：标记清除：" class="headerlink" title="fullGC之一：标记清除："></a>fullGC之一：标记清除：</h3><p><img src="https://img-blog.csdnimg.cn/20200210120137411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>优点：<br>不需要额外内存空间。</p>
<p>缺点：<br>算法执行时要暂停应用并进行两次扫描（先扫描定位，后扫描删除）耗时严重，会产生内存碎片，即这种方式清理出来的空闲内存是不连续的，这点不难理解，我们的死亡对象都是随即的出现在内存的各个角落的，现在把它们清除之后，内存的布局自然会乱七八糟。而为了应付这一点，JVM就<strong>不得不维持一个内存的空闲列表</strong>，这又是一种开销。而且在分配数组对象的时候，寻找连续的内存空间会不太好找。 </p>
<p>在Java语言里，可作为GC Roots对象一般为虚拟机栈，本地方法栈和方法区内的属性或常量引用的对象。没有被GC Roots引用的对象会被回收。</p>
<h3 id="fullGC之二：标记整理："><a href="#fullGC之二：标记整理：" class="headerlink" title="fullGC之二：标记整理："></a>fullGC之二：标记整理：</h3><p>标记整理也叫标记压缩：<br>先标记出来存活的对象，然后统一向一端移动对象。形成可回收与不可回收的边界，边界另一边的对象将被回收。<br><img src="https://img-blog.csdnimg.cn/20200210121058115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>优点：<br>因为对象的存储是连续的，JVM只需要持有一个内存的起始地址即可，相对于标记清除维护一个空闲列表显然<strong>少了许多内存开销</strong>。且也不需要额外的内存空间。</p>
<p>缺点：<br>标记/整理算法唯一的缺点就是效率也不高，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。<br>从<strong>效率</strong>上来说，标记/整理算法要低于复制算法。 </p>
<p>fullGC实际上一般使用标记清除压缩的方式，将两者集合使用。<br>还有一种已经不再使用的引用计数法，无法解决循环引用的问题。</p>
<h1 id="永久区-perm（java7之前）"><a href="#永久区-perm（java7之前）" class="headerlink" title="永久区 perm（java7之前）"></a>永久区 perm（java7之前）</h1><p>永久存储区是一个常驻内存区域，<strong>在方法区中</strong>，用于存放JDK自身所携带的 <strong>Class,Interface 的元数据，也就是说它存储的是运行环境必须的类信息</strong>，被装载进此区域的数据是不会被垃圾回收器回收掉的，<strong>关闭 JVM 才会释放此区域所占用的内存。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/202002101158448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="永久区其实是在方法区内实现的。"></p>
<p>JDK8开始废弃永久代（PermGen）迎来元空间（Metaspace）存储的位置也从方法区中换到了本地内存中（Metaspace）。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/jvm-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/jvm-1/" class="post-title-link" itemprop="url">JVM学习笔记一：JVM体系结构概览</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:17:49 / Geändert am: 17:19:47" itemprop="dateCreated datePublished" datetime="2020-08-16T17:17:49+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、jvm总览："><a href="#一、jvm总览：" class="headerlink" title="一、jvm总览："></a>一、jvm总览：</h1><p>jvm的位置：在运行操作系统上，与硬件没有直接的交互。<br>jvm与操作系统，底层硬件三者的关系如下：<br><img src="https://img-blog.csdnimg.cn/20200209183805144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>下面是JVM虚拟机的结构图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200210123651757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>方法区和堆是所有线程共享的内存区域；而java栈、本地方法栈和程序计数器是运行是线程私有的内存区域。<br>下面几个部分逐个对上图的各个部分进行剖析：</p>
<h1 id="二、类加载器Class-Loader"><a href="#二、类加载器Class-Loader" class="headerlink" title="二、类加载器Class Loader"></a>二、类加载器Class Loader</h1><p>  类加载器负责加载class文件，class文件在文件开头有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成<strong>方法区</strong>中的运行时数据结构。<br>  类加载器只负责class文件的加载，至于它是否可以运行，则由Execution Engine执行引擎决定 。<br>  <img src="https://img-blog.csdnimg.cn/20200209184807638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图：类加载器将javac编译过的字节码文件进行加载，并初始化为一个Class，这里的Class相当于一个类的模版，jvm中这个类的实例都要按照这个模版实例化。</p>
<ul>
<li>类加载的双亲委派机制：</li>
</ul>
<p>当一个类收到了类加载请求，他首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），子类加载器才会尝试自己去加载。 即所有类的加载先去找最顶层的加载器，找不到再继续向下找，直到找到为止。</p>
<p>采用双亲委派的一个好处是比如加载位于 rt.jar 包中的类 java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，这样就保证了使用不同的类加载器最终得到的都是同样一个 Object对象。 </p>
<p>jvm自带的类加载器及层级关系如下：<br><img src="https://img-blog.csdnimg.cn/20200209185619689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如上图，虚拟机自带的加载器可分为四种，从顶层到下一层分别为：</p>
<ul>
<li>启动类加载器（Bootstrap）：加载rt.jar包内的类，如Object等。</li>
<li>扩展类加载器（Extension）：加载ext目录下所有jar包的类。</li>
<li>应用程序类加载器（AppClassLoader）：一般为用户自己写的类。<br>下面通过一个实例来证明类三种加载器父子关系，需要注意的是：bootstrap最顶层启动类加载器是获取不到的，获取时会输出null：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        System.out.println(o.getClass().getClassLoader().getParent());<span class="comment">//会直接报错java.lang.NullPointerException</span></span><br><span class="line">        System.out.println(o.getClass().getClassLoader());<span class="comment">//null 启动类加载器java内获取不到</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*************************************&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MyObject myObject = <span class="keyword">new</span> MyObject();</span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader().getParent().getParent());<span class="comment">//启动类加载器 ： null</span></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader().getParent());<span class="comment">//扩展类加载器 extension</span></span><br><span class="line">        System.out.println(myObject.getClass().getClassLoader());<span class="comment">//应用程序类加载器 application</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下（获取bootstrap的父加载器会报错，运行时已经注释掉）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">null</span> <span class="comment">//启动类加载器，获取不到</span></span><br><span class="line">*************************************</span><br><span class="line"><span class="keyword">null</span><span class="comment">//启动类加载器，获取不到</span></span><br><span class="line">sun.misc.Launcher$ExtClassLoader@<span class="number">1540e19d</span><span class="comment">//extend扩展类加载器</span></span><br><span class="line">sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2<span class="comment">//应用程序加载器</span></span><br></pre></td></tr></table></figure>


<h1 id="三、执行引擎，native相关，程序计数器，方法区"><a href="#三、执行引擎，native相关，程序计数器，方法区" class="headerlink" title="三、执行引擎，native相关，程序计数器，方法区"></a>三、执行引擎，native相关，程序计数器，方法区</h1><ul>
<li><p>Execution Engine执行引擎负责解释命令，<strong>提交操作系统执行</strong>。</p>
</li>
<li><p>本地方法栈和本地接口：在本地方法栈中登记native方法，在Execution Engine 执行时加载本地方法库。本地接口的作用是融合不同的编程语言为 Java 所用，可以实现<strong>java与底层硬件的交互</strong>，企业级应用较少。</p>
</li>
<li><p>程序计数器：是线程私有的,就是一个指针，<strong>指向方法区中的方法字节码</strong>（用来存储指向下一条指令的地址,也即将要执行的指令代码），由执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不记。<br>这块内存区域很小，它是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来选取下一条需要执行的字节码指令。用以完成分支、循环、跳转、异常处理、线程恢复等基础功能。不会发生内存溢出(OutOfMemory=OOM)错误</p>
</li>
<li><p>供各线程共享的运行时内存区域。它<strong>存储了每一个类的结构信息</strong>，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。可以理解为存储了类的模版结构，模版内包括方法，构造函数等等类的组成部分。</p>
</li>
</ul>
<h1 id="四、栈"><a href="#四、栈" class="headerlink" title="四、栈"></a>四、栈</h1><p>栈也叫栈内存，主管Java程序的运行，是在线程创建时创建，它的生命期跟随线程的生命期，线程结束栈内存也就释放，对于栈来说不存在垃圾回收问题，只要线程一结束该栈就Over，<strong>生命周期和线程一致</strong>，是线程私有的。<strong>8种基本类型的变量+对象的引用+实例方法都是在函数的栈内存中分配</strong>。</p>
<h2 id="1-栈存储什么-："><a href="#1-栈存储什么-：" class="headerlink" title="1.栈存储什么?："></a>1.栈存储什么?：</h2><p>栈帧中主要保存3 类数据：</p>
<ul>
<li><p>局部变量（Local Variables）:输入参数和输出参数以及方法内的变量。</p>
</li>
<li><p>栈操作（Operand Stack）:记录出栈、入栈的操作。</p>
</li>
<li><p>栈帧数据（Frame Data）:包括类文件、方法等等。</p>
</li>
<li><h2 id="2-栈运行原理："><a href="#2-栈运行原理：" class="headerlink" title="2.栈运行原理："></a>2.栈运行原理：</h2><p>栈中的数据都是以栈帧（Stack Frame）的格式存在，栈帧是一个内存区块，是一个数据集，是一个有关方法(Method)和运行期数据的数据集，当一个方法A被调用时就产生了一个栈帧 F1，并被压入到栈中，A方法又调用了 B方法，于是产生栈帧 F2 也被压入栈，B方法又调用了 C方法，于是产生栈帧 F3 也被压入栈，<br>……<br>执行完毕后，先弹出F3栈帧，再弹出F2栈帧，再弹出F1栈帧……</p>
</li>
</ul>
<p>遵循“先进后出”/“后进先出”原则。</p>
<p>每个方法执行的同时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。栈的大小和具体JVM的实现有关，通常在256K~756K之间,与等于1Mb左右。</p>
<p>即：调用哪个方法，哪个方法入栈，执行完哪个方法，哪个方法就需要出栈，出栈时要依次先将栈顶的栈帧弹出，再弹出自己。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>
<p>往往是因为栈内存溢出，造成的原因经常是有方法递归调用自己，没有递归终止条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    m1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行前&quot;</span>);</span><br><span class="line">    m1();<span class="comment">//Exception in thread &quot;main&quot; java.lang.StackOverflowError</span></span><br><span class="line">    System.out.println(<span class="string">&quot;执行后&quot;</span>);<span class="comment">//无法输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-栈-堆-方法区的交互关系"><a href="#3-栈-堆-方法区的交互关系" class="headerlink" title="3.栈+堆+方法区的交互关系"></a>3.栈+堆+方法区的交互关系</h2><p><img src="https://img-blog.csdnimg.cn/2020020920104173.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于一个对象：</p>
<ul>
<li>栈中保存的是对象在堆中实例的引用</li>
<li>堆中保存对象的实例以及对象在方法区中的对象类型的引用</li>
<li>方法区保存的是对象的模版，对象的类型数据。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-6/" class="post-title-link" itemprop="url">JUC学习笔记六：synchronized和ReentrantLock详解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:10:57 / Geändert am: 17:17:26" itemprop="dateCreated datePublished" datetime="2020-08-16T17:10:57+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>synchronized关键字是通过jvm实现的</p>
<p>在jdk1.6之前：简单粗暴的字节码层面实现同步。</p>
<ul>
<li>如果使用同步代码块，那么就是通过monitorenter和monitorexit指明同步代码块开始和结束的位置，synchronized代码块会维护一个锁计数器，当enter时，先判断计数器是不是0，如果是0就进入，进入之后将计数器加1，在退出时将计数器设为0，表明锁被释放。</li>
<li>如果使用同步方法，那么这个方法的字节码会有一个标识 ACC_SYNCHRONIZED，如果字节码运行的时候遇到这个标识，就会调用同步机制加锁。</li>
</ul>
<p>在jdk1.6之后：引入了锁升级的过程<br>1.6之后synchronized的性能有了很大的提升，他并不是上来就加上最重量级的锁。而是有四个状态，根据线程竞争的激烈程度从无锁到重量级锁逐步升级。<br>这四个状态分别是：无锁–&gt;偏向锁–&gt;轻量级锁–&gt;重量级锁</p>
<p>无锁：就是没有锁<br>偏向锁：无线程竞争，偏向于先进来的线程，先进来的线程获得偏向锁，如果这个锁没有被其他进来的线程获取，那么持有偏向锁的线程就无需同步。<br>轻量级锁：就是自旋锁，通过CAS实现<br>重量级锁：同1.6之前</p>
<p>其他概念：<br>锁消除：检测到某些数据不可能存在线程竞争，转变为无锁，锁被消除。<br>锁粗化：原则上，我们在编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p>
<h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>ReentrantLock可以有两种模式，默认是非公平锁，但是如果构造器传了true， 那么就是公平锁。<br>实现方式：CAS和AQS双向队列实现</p>
<p>公平锁模式：<br>调用lock.lock()：<br>先调用AQS的acquire方法，将线程放进队列，然后判断这个进队列的线程前面的结点有没有等待时间更长的线程，如果有，让等待时间最长的线程获得锁，如果没有，那么这个线程获得锁。</p>
<p>非公平锁模式：<br>调用lock.lock():<br>不管三七二十一先CAS抢锁，没抢到再去调用acquire()排队，也就是说虽然也有aqs队列，但是不能保证队列头部的线程能获取到锁，因为所有其他线程第一次进来都有获取锁的权力。</p>
<p>为什么叫可重入？<br>维护一个int state，线程A获得锁，state加1，线程A还可以再获得锁，state再加1，变为2，直到线程A释放两次锁，state变为0时，其他线程才能再去获得锁，线程A可以通过同一把锁重入，这就是可重入锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-5/" class="post-title-link" itemprop="url">JUC学习笔记五：四大函数式接口和流Stream; ForkJoinPool</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:10:21 / Geändert am: 17:17:21" itemprop="dateCreated datePublished" datetime="2020-08-16T17:10:21+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、四大函数式接口和Stream"><a href="#一、四大函数式接口和Stream" class="headerlink" title="一、四大函数式接口和Stream"></a>一、四大函数式接口和Stream</h1><h2 id="四大函数式接口："><a href="#四大函数式接口：" class="headerlink" title="四大函数式接口："></a>四大函数式接口：</h2><p>函数式接口是java8的新特性之一：它封装好了四种不同功能的函数式接口。都位于java.util.function包下。可以从接口的名字来记忆接口有无返回值，有无参数等等。下面表格是具体介绍：</p>
<p><img src="https://img-blog.csdnimg.cn/20200208094913835.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>消费型Consumer：输入一个参数，这个参数被消费了，无返回值：有参数，无返回值。</li>
<li>供给型Supplier：没有输入参数，但是程序供给出来了返回值：无参数，有返回值。</li>
<li>函数型接口Function：函数是有输入有输出的。所以有参数，有返回值。</li>
<li>断定型接口Predicate：给程序一个参数，程序用这个参数断言是否符合某条件：有参数，返回值为boolean类型。</li>
</ul>
<p>下面分别举例四种接口的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionalInterfaceDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         <span class="comment">//函数型接口（泛型左边为入参，右边为返回类型）</span></span><br><span class="line">        Function&lt;String, Integer&gt; function = s -&gt; s.length();<span class="comment">//有一个输入，有一个输出</span></span><br><span class="line">        System.out.println(function.apply(<span class="string">&quot;Younjzxx&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断定型接口，输入任何类型，输出的是对于这个输入参数的某种逻辑判断，true或者false</span></span><br><span class="line">        Predicate&lt;String&gt; predicate = s -&gt; s.equals(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        System.out.println(predicate.test(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消费型接口，输入某个参数，用这个参数做某个业务，无返回值</span></span><br><span class="line">        Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line">        consumer.accept(<span class="string">&quot;print me ~&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//供给型接口，无参数，有返回值。</span></span><br><span class="line">        Supplier&lt;String&gt; supplier = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;供给型接口&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(supplier.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">print me ~</span><br><span class="line">供给型接口</span><br></pre></td></tr></table></figure>

<h2 id="流Stream："><a href="#流Stream：" class="headerlink" title="流Stream："></a>流Stream：</h2><p>流(Stream) 到底是什么呢？<br>是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<br>其实就是将集合或者数组的每一个元素分离开，形成一条一条“流”的形式，用这些流进行各种集合中元素的操作。</p>
<p>Stream流的特点：<br>1.Stream 自己不会存储元素<br>2.Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。<br>3.Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p>
<p>使用方法：<br>1.创建一个Stream：一个数据源（数组、集合）<br>2.中间操作：一个中间操作，处理数据源数据<br>3.终止操作：一个终止操作，执行中间操作链，产生结果</p>
<p>下面我们创建一个数组的list，然后用这个list来进行流式编程。list内存储的是自定义的User对象，User定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>     age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们创建一个含有5个User对象的list：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User u1 = <span class="keyword">new</span> User(<span class="number">11</span>, <span class="string">&quot;a&quot;</span>, <span class="number">23</span>);</span><br><span class="line">      User u2 = <span class="keyword">new</span> User(<span class="number">12</span>, <span class="string">&quot;b&quot;</span>, <span class="number">24</span>);</span><br><span class="line">      User u3 = <span class="keyword">new</span> User(<span class="number">13</span>, <span class="string">&quot;c&quot;</span>, <span class="number">22</span>);</span><br><span class="line">      User u4 = <span class="keyword">new</span> User(<span class="number">14</span>, <span class="string">&quot;d&quot;</span>, <span class="number">28</span>);</span><br><span class="line">      User u5 = <span class="keyword">new</span> User(<span class="number">16</span>, <span class="string">&quot;e&quot;</span>, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">      List&lt;User&gt; list = Arrays.asList(u1, u2, u3, u4, u5);</span><br></pre></td></tr></table></figure>

<p>我们要得到的结果是：输出偶数id，年龄大于24，用户名显示为大写且用户名字母倒排序。只输出排序后第一个用户的用户名。<br>用Stream可以方便的完成这个需求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list.stream().filter(u -&gt; u.getId() % <span class="number">2</span> == <span class="number">0</span>).filter(u -&gt; u.getAge() &gt; <span class="number">24</span>).</span><br><span class="line">                map(m -&gt; &#123;</span><br><span class="line">                    <span class="keyword">return</span> m.getUserName().toUpperCase();</span><br><span class="line">                &#125;).sorted((s1, s2) -&gt; -s1.compareTo(s2)).limit(<span class="number">1</span>).forEach(System.out::println);<span class="comment">//sout : E</span></span><br></pre></td></tr></table></figure>

<h1 id="二、ForkJoin分支合并框架"><a href="#二、ForkJoin分支合并框架" class="headerlink" title="二、ForkJoin分支合并框架"></a>二、ForkJoin分支合并框架</h1><h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h2><p>Fork：把一个复杂任务进行分拆，大事化小<br>Join：把分拆任务的结果进行合并</p>
<p>ForkJoinPool：分支合并池，可以类比线程池<br><img src="https://img-blog.csdnimg.cn/20200208102843691.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>ForkJoinTask    类比=&gt;   FutureTask<br><img src="https://img-blog.csdnimg.cn/20200208103025551.bmp" alt="在这里插入图片描述"></p>
<p>RecursiveTask：递归任务，继承了ForkJoinTask，一般直接继承RecursiveTask即可。<br>继承后可以实现递归(自己调自己)调用的任务：</p>
<h2 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h2><p>例子：使用ForkJoin实现从a到b的所有整数的和：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyTask myTask = <span class="keyword">new</span> MyTask(<span class="number">50</span>, <span class="number">100</span>);</span><br><span class="line">        ForkJoinPool threadPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Integer&gt; forkJoinTask = threadPool.submit(myTask);</span><br><span class="line">        System.out.println(forkJoinTask.get());<span class="comment">//输出结果3825</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接继承RecursiveTask&lt;&gt;抽象类，它继承了ForkJoinTask&lt;&gt;抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//10以内不用拆分</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer ADJUST_VALUE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> begin;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.begin = begin;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((end - begin) &lt;= ADJUST_VALUE)&#123;</span><br><span class="line">            <span class="comment">//end和begin相差不到10，不需要forkJoin</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt;= end; i++)&#123;</span><br><span class="line">                result = result + i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (begin + end)/<span class="number">2</span>;</span><br><span class="line">            <span class="comment">//任务1</span></span><br><span class="line">            MyTask task01 = <span class="keyword">new</span> MyTask(begin,middle);</span><br><span class="line">            <span class="comment">//任务2</span></span><br><span class="line">            MyTask task02 = <span class="keyword">new</span> MyTask(middle+<span class="number">1</span>,end);</span><br><span class="line">            <span class="comment">//递归地分任务</span></span><br><span class="line">            task01.fork();</span><br><span class="line">            task02.fork();</span><br><span class="line">            result =  task01.join() + task02.join();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-4/" class="post-title-link" itemprop="url">JUC学习笔记四：ThreadPool线程池</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:09:47 / Geändert am: 17:17:16" itemprop="dateCreated datePublished" datetime="2020-08-16T17:09:47+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="ThreadPool线程池"><a href="#ThreadPool线程池" class="headerlink" title="ThreadPool线程池"></a>ThreadPool线程池</h1><h2 id="线程池的优势："><a href="#线程池的优势：" class="headerlink" title="线程池的优势："></a>线程池的优势：</h2><p>在多核cpu没有普及的年代，单核cpu就像是假的多线程。一个cpu需要在多个线程之间来回切换。现在的多核电脑，多个线程可以各自跑在独立的CPU上，不用切换，效率高。</p>
<p>线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</p>
<p>它的主要特点为：线程复用;控制最大并发数;管理线程。</p>
<ul>
<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li>第二：提高响应速度。当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。  </li>
</ul>
<h2 id="线程池的三大方法-："><a href="#线程池的三大方法-：" class="headerlink" title="线程池的三大方法 ："></a>线程池的三大方法 ：</h2><p>首先，我们要先明确和线程池有关的类和接口的关系，如下图：<br><img src="https://img-blog.csdnimg.cn/20200207171422501.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>可以发现，我们经常拿来引用的ExecutorService是一个接口，它也继承了Executor接口，Executor接口中只定义了<code>void execute(Runnable command);</code>一个方法，ExecutorService则多定义了线程池的几个操作方法，如<code>shutdown()</code>等。  </p>
<p>在这之前，我一直使用的创建线程池的方法是，调用Executors工具类里面封装好的创建特定线程池的静态方法，包括：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);<span class="comment">//一个池子里面5个工作线程</span></span><br><span class="line">ExecutorService threadPool2 = Executors.newSingleThreadExecutor();<span class="comment">//相当于一个池子仅有1个工作线程</span></span><br><span class="line">ExecutorService threadPool3 = Executors.newCachedThreadPool();<span class="comment">//根据需要来创建线程，可扩容可收缩</span></span><br></pre></td></tr></table></figure>

<p>这里的三个方法，之前笔记里面已有介绍，不在赘述。<br>点进去这三个静态方法的源码，我们发现他们分别是这样的：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.newFixedThreadPool</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//2.newSingleThreadExecutor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">           (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                   <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                   <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//3.newCachedThreadPool</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                     <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，这三个Executors工具类中的创建线程池的方法，最后实际上都创建出来了一个 【ThreadPoolExecutor】 只是构造器内部的参数不同而已。<br>我们打开阿里巴巴开发手册，看一下开发当中，用哪一种方法创建线程池最好。结果如下：  </p>
<p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明：Executors 返回的线程池对象的弊端如下：<br>1）FixedThreadPool 和 SingleThreadPool:   允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。<br> 2）CachedThreadPool 和 ScheduledThreadPool:   允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。<br> （此段内容来自阿里巴巴java开发手册1.4.0）</p>
<p>很明显，得到的答案是用更加手动化的<code>ThreadPoolExecutor</code>来根据业务需要定制创建线程池。  </p>
<h2 id="线程池的七大重要参数："><a href="#线程池的七大重要参数：" class="headerlink" title="线程池的七大重要参数："></a>线程池的七大重要参数：</h2><p>确定了创建线程池要用的方法之后，就要去看如何用new ThreadPoolExecutor的方法创建线程池，打开ThreadPoolExecutor的构造器（其中有很多重载的方法，不管哪个方法前五个参数必须手动设置）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>这七个参数分别是：</p>
<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大池的大小</li>
<li>keepAliveTime：存活时间</li>
<li>unit：时间单位</li>
<li>workQueue：工作的阻塞队列</li>
<li>threadFactory：创建线程的工厂类（一般使用默认即可）</li>
<li>handler：拒绝策略</li>
</ul>
<p>当设定好这几个参数，线程池会怎样运行呢？<br>首先先来看线程池的工作流程：<br><img src="https://img-blog.csdnimg.cn/20200207174005233.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解释：<br>1.首先，假设和图中一样，<code>corePoolSize</code> = 2，<code>maximumPoolSize</code>= 5，<code>workQueue</code>为容量等于3的阻塞队列。第1步，来了两个线程需要执行，线程池会调用核心池里面的两个线程来执行。</p>
<p>2.核心池里面的线程正在执行，此时又来了三个需要执行的线程，【此时，线程池并不会直接将扩容，而是先将这些线程放入阻塞队列中】，此时一共有五个线程。两个在核心池运行当中，三个在阻塞队列中等待。</p>
<p>3.此时，假设又来了3个需要执行的线程。【此时，阻塞队列已经满了，但是线程池内还没有达到最大线程数，这个时候线程池会才会将容量扩容到5，以便在阻塞队列中等待已久的线程执行】注意：5已经是线程池的最大容量。新来的3个线程进入了空出来的阻塞队列中等待。这个时候整个程序中有8个线程，2个在核心池执行，3个在扩展出来的池子执行，还有三个在阻塞队列中等待，线程池已经不能接受任何一个新的线程的执行请求。</p>
<p>4.此时线程池已经“满载”，连阻塞队列的等待线程也满了，如果这时又来了若干个线程需要执行，那么，线程池就会执行拒绝策略（拒绝策略根据业务的需要分为4种）。 </p>
<h2 id="线程池的执行流程："><a href="#线程池的执行流程：" class="headerlink" title="线程池的执行流程："></a>线程池的执行流程：</h2><p>可以看出，线程池中，线程的处理流程如下：<br><img src="https://img-blog.csdnimg.cn/20200207180313793.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>以下的解释说明了，线程池的工作完整机制。<br>1、在创建了线程池后，开始等待请求。  </p>
<p>2、当调用execute()方法添加一个请求任务时，线程池会做出如下判断：</p>
<ul>
<li>如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；<ul>
<li>如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；</li>
<li>如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；</li>
<li>如果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。 </li>
<li>3、当一个线程完成任务时，它会从队列中取下一个任务来执行。 </li>
</ul>
</li>
</ul>
<p>4、当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：<br>    如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。<br>    所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</p>
<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><h3 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h3><ul>
<li>什么是拒绝策略？什么时候用到？<br>线程池中正在运行的线程数量已经达到maximumPoolSize最大线程容量，同时连阻塞队列都被占满了。这时候，线程池就要执行拒绝策略来拒绝新的线程进入。</li>
<li>四种拒绝策略这里做一个测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                <span class="number">2</span>,<span class="comment">//核心池大小</span></span><br><span class="line">                <span class="number">5</span>,<span class="comment">//最大池大小</span></span><br><span class="line">                <span class="number">2L</span>,</span><br><span class="line">                TimeUnit.SECONDS,<span class="comment">//与上个参数组合为收缩等待时间</span></span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">3</span>),<span class="comment">//长度为3的阻塞队列</span></span><br><span class="line">                Executors.defaultThreadFactory(),<span class="comment">//默认线程工厂</span></span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy()<span class="comment">//分别测试：替换为4种拒绝策略</span></span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//模拟十个线程进来，池子里面最多跑5个线程，阻塞队列容量为3，尝试跑9个线程看看四种拒绝策略如何拒绝</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                threadPool.execute(() -&gt; &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  办理业务&quot;</span>);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            threadPool.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<ol>
<li>AbortPolicy(默认)：直接抛出RejectedExecutionException异常阻止系统正常运行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>  办理业务</span><br><span class="line">java.util.concurrent.RejectedExecutionException</span><br></pre></td></tr></table></figure>

<p> 2..CallerRunsPolicy：“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务回退到调用者，从而降低新任务的流量。这里是main主线程启动了线程池，所以多余的一个线程交给了main线程执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">main  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br></pre></td></tr></table></figure>

<p>3.DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理也不抛出异常。<br>如果允许任务丢失，这是最好的一种策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>  办理业务</span><br></pre></td></tr></table></figure>
<p>4.DiscardOldestPolicy：抛弃队列中等待最久的任务，然后把当前任务加人队列中尝试再次提交当前任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>  办理业务</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>  办理业务</span><br></pre></td></tr></table></figure>

<p>具体用哪一种拒绝策略，由业务需要决定。<br>实际工作中，不能用三大方法建立线程池！当然，手写小的demo建立多线程时可以使用无妨。  </p>
<h3 id="合理设置最大线程数"><a href="#合理设置最大线程数" class="headerlink" title="合理设置最大线程数"></a>合理设置最大线程数</h3><p>tips：如何设置最大线程数最合理？</p>
<ul>
<li><p>CPU密集型：线程个数为CPU核数或者多一点点。这几个线程可以并行执行，不存在线程切换到开销，提高了cpu的利用率的同时也减少了切换线程导致的性能损耗 。</p>
</li>
<li><p>IO密集型：线程个数为CPU核数的两倍。其中一半的线程在IO操作的时候，另一半线程可以继续用cpu做其他事情，提高了cpu的利用率 。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-3/" class="post-title-link" itemprop="url">JUC学习笔记三：AQS并发工具类；读写锁；阻塞队列</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:09:22 / Geändert am: 17:17:11" itemprop="dateCreated datePublished" datetime="2020-08-16T17:09:22+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、AQS并发工具类"><a href="#一、AQS并发工具类" class="headerlink" title="一、AQS并发工具类"></a>一、AQS并发工具类</h1><h2 id="1-CountDownLatch：倒计时门栓"><a href="#1-CountDownLatch：倒计时门栓" class="headerlink" title="1.CountDownLatch：倒计时门栓"></a>1.CountDownLatch：倒计时门栓</h2><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>  A synchronization aid that allows one or more threads to wait until<br>   a set of operations being performed in other threads completes.<br>（大意就是：可以控制一个或者多个特定的线程在若干个线程执行完毕之后才执行）        </p>
<p>来个土味社会语录：先穿袜子再穿鞋，先当孙子再当爷~<br>这里的穿鞋，必须等到所有袜子穿好之后，才可以进行。同理，想成为大佬，假设必须经过一千次向大佬请教。那么想成为大佬就必须等到请教一千次大佬动作完成之后才能进行。 类似这种需求可以考虑使用CountDownLatch实现</p>
<p>CountDownLatch的构造器： 参数为计数器的初始值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>  下面用穿袜子来举例，必须穿好两只袜子才可以穿鞋。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t穿上了一只袜子&quot;</span>);</span><br><span class="line">                countDownLatch.countDown();<span class="comment">//计数器减一，减到零之后,调用了await()方法而在等待的线程就会被唤醒。</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t穿鞋&quot;</span>);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>    穿上了一只袜子</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>    穿上了一只袜子</span><br><span class="line">main    穿鞋</span><br></pre></td></tr></table></figure>

<p>若没有使用CountDownLatch，可能出现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main    穿鞋</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>    穿上了一只袜子</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>    穿上了一只袜子</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>    穿上了一只袜子</span><br><span class="line">main    穿鞋</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>    穿上了一只袜子</span><br></pre></td></tr></table></figure>
<p>这样先穿了鞋再穿袜子，明显错误。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p> 每次CountDownLatch对象的countDown()方法，就会使设定好的计数器的值减一（类似于倒计时），若设定好的计数器减到零（倒计时结束，await()的线程放行）：那么调用了CountDownLatch对象的await()方法的线程就会执行。    </p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化方式</span></span><br><span class="line">CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="keyword">int</span> count);</span><br><span class="line"><span class="comment">//主要方法</span></span><br><span class="line">countDownLatch.countDown();<span class="comment">//计数器count减一</span></span><br><span class="line">countDownLatch.await();<span class="comment">//线程等待，直到计数器count归零</span></span><br></pre></td></tr></table></figure>

<h2 id="2-CyclicBarrier：循环障碍"><a href="#2-CyclicBarrier：循环障碍" class="headerlink" title="2.CyclicBarrier：循环障碍"></a>2.CyclicBarrier：循环障碍</h2><h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.  CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called <em>cyclic</em> because it can be re-used after the waiting threads are released.  </p>
<p>和CountDownLatch类似：也是一些线程要等待另一些线程执行完毕后，才能执行的场景。  </p>
<p>与CountDownLatch不同的是：CyclicBarirer可以通过reset()方法再次循环使用，并不是像CountDownLatch一样用过就当垃圾丢掉的。 </p>
<p>CyclicBarrier的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br><span class="line"><span class="function"><span class="comment">//parties:the number of threads that must invoke &#123;@link #await&#125; before the barrier is tripped(在障碍物消失之前，必须执行的线程的个数，即执行第二个参数中的线程之前必须执行的线程的数量)</span></span></span><br><span class="line"><span class="function"><span class="comment">//the command to execute when the barrier is tripped（障碍物消失之后，要执行的命令）</span></span></span><br></pre></td></tr></table></figure>

<h3 id="举例：-1"><a href="#举例：-1" class="headerlink" title="举例："></a>举例：</h3><p>葫芦娃合体，必须等七个葫芦娃全都准备就绪才可以合体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">7</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;葫芦娃合体！&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;=<span class="number">7</span> ; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;\t&quot;</span>+temp+<span class="string">&quot;娃来了，准备合体&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>    <span class="number">1</span>娃来了，准备合体</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>    <span class="number">5</span>娃来了，准备合体</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>    <span class="number">2</span>娃来了，准备合体</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>    <span class="number">4</span>娃来了，准备合体</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>    <span class="number">3</span>娃来了，准备合体</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>    <span class="number">7</span>娃来了，准备合体</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>    <span class="number">6</span>娃来了，准备合体</span><br><span class="line">葫芦娃合体！</span><br></pre></td></tr></table></figure>
<h3 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h3><p>同样通过计数器来计算执行过的线程数，只不过每次变为加1而不是减1。每调用一次CyclicBarrier对象的await()方法，标示着一个线程到达了屏障，计数器加一。<br>当计数器的值等于入参中的parties的值时，barrierAction会执行一次。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化方式</span></span><br><span class="line">CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="keyword">int</span> parties, Runnable barrierAction);</span><br><span class="line"><span class="comment">//主要方法</span></span><br><span class="line">cyclicBarrier.await();<span class="comment">//计数器加一，计数器的值等于parties时，barrierAction执行</span></span><br></pre></td></tr></table></figure>



<h2 id="3-Semaphore"><a href="#3-Semaphore" class="headerlink" title="3.Semaphore:"></a>3.Semaphore:</h2><h3 id="应用场景：-2"><a href="#应用场景：-2" class="headerlink" title="应用场景："></a>应用场景：</h3><p> A counting semaphore.  Conceptually, a semaphore maintains a set of permits.  Each {@link #acquire} blocks if necessary until a permit is<br>available, and then takes it.  Each {@link #release} adds a permit,<br> potentially releasing a blocking acquirer.<br>However, no actual permit objects are used; the {@code Semaphore} just keeps a count of the number available and acts accordingly.  </p>
<p>如果有些资源数量是有限的，但是需要这个资源的线程数量比资源数量多，那么为了资源的并发安全，我们可以使用Semaphore ，最多只允许等于资源数的线程数量进入，并且使用完资源可以释放使用权给其他线程（release），其他线程一旦进入就占领一个资源（acquire）  </p>
<p>Semaphore的构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//permits：最大资源数量的初始值，不能为负数</span></span></span><br></pre></td></tr></table></figure>

<h3 id="举例-："><a href="#举例-：" class="headerlink" title="举例 ："></a>举例 ：</h3><p>这里用食堂抢桌子座位来模拟，食堂一个桌子有四个座位，十个人要吃饭。要保证一个座位一个人，不能有四个人以上同时吃饭，并且吃完释放座位给其他人用。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//多个线程抢多个资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//八个人食堂抢座位,最多四个人入座，不关心是谁</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">4</span>);</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();<span class="comment">//perimit不为0时，才能进来，每进来一个线程permit减1</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;抢到了一个座位&quot;</span>);</span><br><span class="line">                    <span class="comment">//暂停一会线程以便观察</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;吃完饭了，离开了座位&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//吃完饭释放座位</span></span><br><span class="line">                    semaphore.release();<span class="comment">//每跑完一个线程permit加1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>抢到了一个座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span>吃完饭了，离开了座位</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span>吃完饭了，离开了座位</span><br></pre></td></tr></table></figure>

<h3 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h3><p>创建 Semaphore 对象的时候，需要一个参数 permits，这个permits代表最大的资源数，然后每个线程调用 acquire 的时候，执行 permits = permits - 1，release 的时候执行 permits = permits + 1，当然，acquire 的时候，如果 permits = 0，说明没有资源了，需要等待其他线程 release。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化方式</span></span><br><span class="line">Semaphore semaphore = <span class="keyword">new</span> semaphore(<span class="keyword">int</span> permits);</span><br><span class="line"><span class="comment">//主要方法</span></span><br><span class="line">semaphore.aquire();    <span class="comment">//permit不为零的情况下，占领一个资源,permit-1</span></span><br><span class="line">semaphore.release();<span class="comment">//释放一个资源,permit+1</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h1 id="二、读写锁-ReadWriteLock"><a href="#二、读写锁-ReadWriteLock" class="headerlink" title="二、读写锁  ReadWriteLock"></a>二、读写锁  ReadWriteLock</h1><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>读写锁的特点是给读写操作的线程进行定制化处理，给每一个写操作的线程赋予唯一一把write锁。但是对只读操作的read锁可以由多个线程获得。</p>
<h3 id="举例：-2"><a href="#举例：-2" class="headerlink" title="举例："></a>举例：</h3><p>5个线程负责向一个map写入数据，另外五个线程负责从map读数据：  </p>
<p>给读方法内加上read锁，给写方法内加上write锁。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//5个写线程，5个读线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CacheMethods cacheMethods = <span class="keyword">new</span> CacheMethods();</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                cacheMethods.write(temp+<span class="string">&quot;&quot;</span>, temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            service.execute(() -&gt; &#123;</span><br><span class="line">                cacheMethods.read(temp+<span class="string">&quot;&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CacheMethods</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        readWriteLock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 写入数据 : &quot;</span>+key);</span><br><span class="line">            <span class="comment">//模拟网路延迟写入数据暂停一会</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 写入完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        readWriteLock.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 读取数据&quot;</span>);</span><br><span class="line">            <span class="comment">//模拟网路延迟读取数据暂停一会</span></span><br><span class="line">            TimeUnit.MILLISECONDS.sleep(<span class="number">300</span>);</span><br><span class="line">            Object result = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; : 读取完成 : &quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            readWriteLock.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> : 写入数据 : <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">1</span> : 写入完成</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> : 写入数据 : <span class="number">2</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">3</span> : 写入完成</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> : 写入数据 : <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">2</span> : 写入完成</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> : 写入数据 : <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">4</span> : 写入完成</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> : 写入数据 : <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">5</span> : 写入完成</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> : 读取数据</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span> : 读取数据</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span> : 读取数据</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span> : 读取数据</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span> : 读取数据</span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">9</span> : 读取完成 : <span class="number">3</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">10</span> : 读取完成 : <span class="number">4</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">6</span> : 读取完成 : <span class="number">0</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">7</span> : 读取完成 : <span class="number">1</span></span><br><span class="line">pool-<span class="number">1</span>-thread-<span class="number">8</span> : 读取完成 : <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以看出，写操作在进行的时候，其他的写操作并没有进来。读写锁实现了并发下读写分离的定制化处理。  </p>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化方法</span></span><br><span class="line">ReadWriteLock readWriteLock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"><span class="comment">//读操作的加锁和释放</span></span><br><span class="line">readWriteLock.writeLock().lock();</span><br><span class="line">readWriteLock.writeLock().unlock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//写操作的加锁和释放</span></span><br><span class="line">readWriteLock.readLcok().lock();</span><br><span class="line">readWriteLock.readLcok().unlock();</span><br></pre></td></tr></table></figure>

<h1 id="三、阻塞队列BlockingQueue"><a href="#三、阻塞队列BlockingQueue" class="headerlink" title="三、阻塞队列BlockingQueue"></a>三、阻塞队列BlockingQueue</h1><h3 id="阻塞队列的概念："><a href="#阻塞队列的概念：" class="headerlink" title="阻塞队列的概念："></a>阻塞队列的概念：</h3><p>所谓阻塞队列，其实本身就是数据结构概念中的队列，遵循先入队的元素先出队。所谓阻塞，就是如果队列是有界的，那么在队列元素已满时，入队操作将会被阻塞；同理，在队列中没有任何元素时，出队操作将会被阻塞。 </p>
<h3 id="BlockingQueue的继承关系："><a href="#BlockingQueue的继承关系：" class="headerlink" title="BlockingQueue的继承关系："></a>BlockingQueue的继承关系：</h3><p><img src="https://img-blog.csdnimg.cn/20200206221741182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzE0MTQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="BlockingQueue接口的主要实现类："><a href="#BlockingQueue接口的主要实现类：" class="headerlink" title="BlockingQueue接口的主要实现类："></a>BlockingQueue接口的主要实现类：</h3><ul>
<li><p>ArrayBlockingQueue ：底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</p>
</li>
<li><p>LinkedBlockingQueue ：底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</p>
</li>
<li><p>SynchronousQueue ：本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</p>
</li>
<li><p>PriorityBlockingQueue： 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</p>
</li>
</ul>
<h3 id="阻塞队列的入队，出队，peek方法："><a href="#阻塞队列的入队，出队，peek方法：" class="headerlink" title="阻塞队列的入队，出队，peek方法："></a>阻塞队列的入队，出队，peek方法：</h3><p>具体方法可见如下表格：<br><img src="https://img-blog.csdnimg.cn/20200206222226278.png" alt="在这里插入图片描述"></p>
<ul>
<li>Throws exception：假设指定了阻塞队列的size(),若add()超过size数量的元素，会直接报<code>java.lang.IllegalStateException: Queue full</code> 。同理，若队列无元素时调用了remove()，会报<code>java.util.NoSuchElementException </code>的错误，调用element()，会报<code>java.util.NoSuchElementException</code>。 </li>
</ul>
<ul>
<li><p>Special value：同理，若执行上面描述中会报错的行为，这里的方法不会报异常，而会返回特定的值：offer返回true或者false；poll返回出队的元素或者null，peek返回队列最先一个能出队的元素或者null.  </p>
</li>
<li><p>Blocks：是实现了真正的阻塞队列的概念，在队列元素已满时，入队操作将会被阻塞；同理，在队列中没有任何元素时，出队操作将会被阻塞。不会返回任何值，程序会等待其他操作来结束阻塞状态。所以所有方法当中比较重要的是【put()，take()】这两个方法。  </p>
</li>
<li><p>Times out：阻塞等待此操作，直到成功或者超时指定时间。时间到达后返回的类型规则同Special value。 </p>
</li>
</ul>
<h3 id="举例：-3"><a href="#举例：-3" class="headerlink" title="举例："></a>举例：</h3><p>下面贴一个小的demo来验证，方法太多结果就不一一贴了，在每个方法的注释处有运行的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//指定队列的容量为3</span></span><br><span class="line">        BlockingQueue&lt;String&gt; blockingQueue  = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">////        System.out.println(blockingQueue.add(&quot;d&quot;));//java.lang.IllegalStateException: Queue full</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());//a</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());//b</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.remove());//c</span></span><br><span class="line"><span class="comment">////        System.out.println(blockingQueue.remove());//java.util.NoSuchElementException</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.add(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.element());//a,取队列能最先出队的元素，相当于数据结构队列中的peek</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;d&quot;));//不报异常，但是返回false</span></span><br><span class="line"><span class="comment">////</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());//a</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());//b</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());//c</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.poll());//null</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        blockingQueue.put(<span class="string">&quot;a&quot;</span>);<span class="comment">//一直等待入队，被阻塞。不报异常，也没有返回值</span></span><br><span class="line"></span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());</span><br><span class="line">        System.out.println(blockingQueue.take());<span class="comment">//一直等待出队，被阻塞。不报异常，也没有返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;a&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;b&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;c&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(blockingQueue.offer(&quot;a&quot;, 3L, TimeUnit.SECONDS));//3秒后输出false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-2/" class="post-title-link" itemprop="url">JUC学习笔记二：线程间的通信；同步方法锁的理解；juc集合类简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:08:59 / Geändert am: 17:17:06" itemprop="dateCreated datePublished" datetime="2020-08-16T17:08:59+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、线程间的通信之while防止虚假唤醒"><a href="#一、线程间的通信之while防止虚假唤醒" class="headerlink" title="一、线程间的通信之while防止虚假唤醒"></a>一、线程间的通信之while防止虚假唤醒</h1><p>  在对多个线程操作共享数据的逻辑进行同步时，要避免使用if判断的方式使某线程进入waiting状态，要改为使用while。原因是while可以防止虚假唤醒：    </p>
<p>  用if使线程进入waiting可能会使判断过的正在等待被唤醒的线程直接进入，不管符不符合if的条件；而while则会重新判断当前正在waiting的线程是否符合while()内的条件，保证多个线程之间不会有虚假唤醒的情况。  </p>
<p>举例：四个线程操作一个数字number，number只能为1或者0，两个线程负责将number加1，另外两个线程负责将number减1。四个线程都各自执行十次，最后执行时要保证number的加1和减1循环交替。（注意，这里使用四个线程作为例子是因为：如果只有两个线程，一个线程唤醒的另一个线程是唯一的。但如果设置为四个线程，一个线程唤醒的其他线程不唯一，就会产生随机性）,这里使用Condition对象的await()和signalAll()方法来操作线程的等待和唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得资源类的对象</span></span><br><span class="line">        AirCondition airCondition = <span class="keyword">new</span> AirCondition();</span><br><span class="line">        <span class="comment">//启动四个线程，两个线程调用加一方法，两个线程调用减一方法，分别执行十次</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使number加1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//线程进入waiting</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++;</span><br><span class="line">            <span class="comment">//唤醒其他所有正在waiting的线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使number减1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number --;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的执行结果（应该应该有40行，这里省略）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">1</span></span><br><span class="line">B:<span class="number">0</span></span><br><span class="line">C:<span class="number">1</span></span><br><span class="line">B:<span class="number">0</span></span><br><span class="line">C:<span class="number">1</span></span><br><span class="line">D:<span class="number">0</span></span><br><span class="line"><span class="comment">//......略  </span></span><br></pre></td></tr></table></figure>


<p>但是，如果我将increment和decrement方法中的while全都替换为if<br>即：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使number加1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//while换成if</span></span><br><span class="line">            <span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使number减1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//while换成if</span></span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number --;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时，运行的结果就可能会产生错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">1</span></span><br><span class="line">B:<span class="number">0</span></span><br><span class="line">C:<span class="number">1</span></span><br><span class="line">A:<span class="number">2</span></span><br><span class="line"><span class="comment">//......略</span></span><br></pre></td></tr></table></figure>
<p>可以发现，这里出现了2的情况。原因如下：  </p>
<ol>
<li><p>线程A、C是加1的线程，B、D是减1的线程。  </p>
</li>
<li><p>在第一行，A抢到了锁，操作number加一并释放锁。  </p>
</li>
<li><p>在第二行的竞争中，C其实最先抢到了锁，但是由于此时number还是1，if条件判断不符合，所以C进入了waiting状态。  </p>
</li>
<li><p>在第三步C进入waiting状态之后，剩下三个线程又开始竞争锁，此时，A又拿到锁，但是由于if的判断，仍然不符合，所以A也进入等待状态。 此时A,C都进入waiting状态。再拿到锁的只能是B或者D减1的方法。</p>
</li>
<li><p>这时B拿到了锁，操作number减1。A，C还在waiting状态。</p>
</li>
<li><p>第二行B执行完毕，唤醒其他线程的瞬间：还在waiting状态的A，C瞬间被唤醒。因为if只在线程第一次拿到锁的时候执行单次判断，C，A此时没有被再次进入if判断，先后立即执行了加一的操作，number变为2，出错。</p>
</li>
</ol>
<p>总结：<br>不能在线程的等待判断逻辑处用if，要用while来保证不会有虚假唤醒，即被唤醒的正在waiting的线程一定会在符合while内条件的情况下才执行。</p>
<p>练习：使用一个lock的多个Condition对象来精准操控线程的执行顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**线程A打印5次，线程B打印10次，线程C打印15次 --- 循环十遍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintData printData = <span class="keyword">new</span> PrintData();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                printData.printTimes(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                printData.printTimes(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                printData.printTimes(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//A : 1, B : 2, C : 3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//使用同一个lock的多个Condition对象来操控多个线程的工作顺序</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition[] conditions = &#123;c1, c2, c3&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTimes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> nextN)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//while防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number != n)&#123;</span><br><span class="line">                conditions[n - <span class="number">1</span>].await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number * <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">                number = nextN;</span><br><span class="line">                conditions[nextN - <span class="number">1</span>].signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、同步方法锁的理解"><a href="#二、同步方法锁的理解" class="headerlink" title="二、同步方法锁的理解"></a>二、同步方法锁的理解</h1><p>如下代码，分别改写为8种情况，写出Phone内方法的打印顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep一下保证默认情况下的先后顺序</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                phone.sendMS();</span></span><br><span class="line"><span class="comment">//                phone.sayHello();</span></span><br><span class="line">                phone2.sendMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.标准访问，两个方法均为普通同步方法-&gt;           email, ms</li>
<li>2.在发邮件方法中暂停4秒-&gt;仍为email,ms 因为是一把锁</li>
<li>3.新增普通非同步sayHello方法在B中执行。-&gt;hello , email:<br>因为普通方法不会被锁 </li>
<li>4.两部手机phone1在A执行发邮件，phone2在B执行发短信 -&gt;              ms, email: 此时先执行没有被暂停四秒的B线程，因为普通同步方法锁的是自身对象，这里有两个对象，就是两把锁，互不干扰。</li>
<li>5.两个静态同步方法-&gt;     email,ms</li>
<li>6.两个静态同步方法，两个手机 -&gt;email,ms：】调用静态的同步方法，锁的就是整个类】锁的是当前类的Class对象，即使是两个不同类的对象，只要是一个类的就会被锁。所以是同一把锁。（注意，前提是二者都是对象）</li>
<li>7.一个静态同步方法，一个普通同步方法，同一部手机-&gt; ms email:同理，静态同步方法的锁是Class，普通同步方法的锁是自身对象。二者不一致，所以是两把锁，互不干扰。</li>
<li>8.一个静态同步方法，一个普通同步方法，两部手机-&gt;  ms email:显然为两把锁。</li>
</ul>
<h1 id="三、juc中的线程安全的集合类简介"><a href="#三、juc中的线程安全的集合类简介" class="headerlink" title="三、juc中的线程安全的集合类简介"></a>三、juc中的线程安全的集合类简介</h1><p>实验：启动三十个不同的线程将三十个随机字符串添加到一个集合类中<br>这里以ArrayList为例，其实换为set和map也有一样的效果  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//启动三十次三十个不同的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//添加三十个不同的随机字符串</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的方法，会报<code>java.util.ConcurrentModificationException</code>的并发修改异常。原因是：普通ArrayList不是线程安全的。解决方式：<br>1.使用Vector<br>2.使用Collections工具类的<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code><br>3.使用 <code>CopyOnWriteArrayList&lt;&gt;()</code>写时复制的list，使用方法：<code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code>即可。</p>
<h2 id="CopyOnWriteArrayList："><a href="#CopyOnWriteArrayList：" class="headerlink" title="CopyOnWriteArrayList："></a>CopyOnWriteArrayList：</h2><p>CopyOnWriteArrayList的类声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList的添加元素的add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>写时复制 copyOnWrite 容器即写时复制的容器 ，往容器添加元素的时候,不直接往当前容器object[]添加,而是先将当前容器object[]进行 copy 复制出一个新的object[] newElements 然后向新容器object[] newElements 里面添加元素 添加元素后，再将原容器的引用指向新的容器 setArray(newElements);<br>这样的好处是可以对copyOnWrite容器进行并发的读,而不需要加锁.所以copyOnwrite容器也是一种<strong>读写分离的思想</strong>,读和写不同的容器.</p>
<p>知识补充：HashSet底层是HashMap，不过这个HashMap的value是一个常量Object。<br>同理：HashSet，HashMap也是线程不安全的，他们也分别可以通过juc包下的<code>**CopyOnWriteSet** </code>和 <code>**ConcurrentHashMap** </code>集合类替代来解决集合的并发问题。</p>
<h2 id="ConcurrentHashMap："><a href="#ConcurrentHashMap：" class="headerlink" title="ConcurrentHashMap："></a>ConcurrentHashMap：</h2><p>我们知道HashMap在多线程情况下不仅不安全，而且会产生死锁。</p>
<p>其中一个解决的办法是使用HashTable，但是HashTable这个容器里面绝大部分方法都是使用synchronized关键字来保证线程安全的，这样的同步显得太过“臃肿”，因为synchronized加到方法上会是一个对象锁，把整个HashTable锁住，一把锁锁整个对象，这样一个线程进来操作HashTable的话，其他所有synchronized方法都不能被其他线程执行，效率非常低下。</p>
<p>那么ConcurrentHashMap就是一个很好的保证线程安全，并且相对来说效率较好的容器。</p>
<p>ConcurrentHashMap如何保证线程安全的？<br>在JDK7中，ConcurrentHashMap是将HashMap分为一个一个的Segment，一个Segment包含多个HashEntry然后再给这些Segment加上分段锁。即同一段Segment才需要考虑同步，不是一段的不考虑。并且get操作无需加锁，ConcurrentHashMap的主干是个Segment数组。继承了ReentrantLock，可重入锁（ReentrantLock)。对于一个key进行三次哈希操作才可以确定最终位置，第一次得到key的hash，第二次得到高位的hash值，确定segment，第三次哈希确定具体在哪个entry</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85OTMwNzYzLWQwMjM1MDExOTFkMTgzOTcucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>JDK8中ConcurrentHashMap的实现使用的是锁分离思想，只是锁住的是一个node(这个node是链表的头结点或者是红黑树的根节点)，而锁住Node之前的操作是基于在volatile和CAS之上无锁并且线程安全的。<br>在插入的过程中（put）若计算出来的位置没有结点占用：通过cas插入即可。如果这个位置上面有元素了，那么synchronized(这个位置链表的头结点)插入到尾部。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-1/" class="post-title-link" itemprop="url">JUC学习笔记一：复习多线程操作资源类的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              

              <time title="Erstellt: 2020-08-16 17:08:07 / Geändert am: 17:08:54" itemprop="dateCreated datePublished" datetime="2020-08-16T17:08:07+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高内聚，低耦合"><a href="#高内聚，低耦合" class="headerlink" title="高内聚，低耦合"></a>高内聚，低耦合</h1><p>所谓高内聚，低耦合就是每个程序要实现的特定功能要尽量多的在自己的内部完成，对外部提供很少量的接口以便调用。</p>
<h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><p>并行即多个任务在自己的分配的各自的资源上执行，即多个任务同时跑，互不冲突。<br>并发即多个任务在统一的一个资源内执行，多个任务会抢占同一资源，在cpu中体现为交替执行，并不能同时执行，但是cpu在多个线程中切换的速度会非常快，所以宏观上看似是同时的。<br>最大的区别体现在【同时】上。<br>并行：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83NTU3MzczLTcyOTEyZWE4ZTg5YzQwMDcuanBn?x-oss-process=image/format,png" alt="并行"><br>并发：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83NTU3MzczLWRhNjRmZmQ2ZDFlZmZhYWMuanBn?x-oss-process=image/format,png" alt="并发"></p>
<h1 id="复习多线程创建的四种方式"><a href="#复习多线程创建的四种方式" class="headerlink" title="复习多线程创建的四种方式"></a>复习多线程创建的四种方式</h1><h2 id="1-创建线程的方式一：继承Thread类的方式"><a href="#1-创建线程的方式一：继承Thread类的方式" class="headerlink" title="1.创建线程的方式一：继承Thread类的方式"></a>1.创建线程的方式一：继承Thread类的方式</h2><p>使用方法：</p>
<ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()<ul>
<li>例子：利用包含main线程在内的三个线程分别遍历10以内所有偶数</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个继承于thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//2. 重写Thread类的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历10以内所有偶数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 通过此对象调用start() 启动当前线程，调用当前线程的run()</span></span><br><span class="line">        <span class="comment">//注意的问题一：我们不能通过直接调用对象.run()启动线程</span></span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要重新创建一个对象再start</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下的操作仍然是在main线程中执行的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ i + <span class="string">&quot;********main()*********&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果（因为线程由操作系统和cpu调度，多次运行结果不同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">6</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">8</span></span><br><span class="line">main:<span class="number">0</span>********main()*********</span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">2</span></span><br><span class="line">main:<span class="number">2</span>********main()*********</span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">6</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">8</span></span><br><span class="line">main:<span class="number">4</span>********main()*********</span><br><span class="line">main:<span class="number">6</span>********main()*********</span><br><span class="line">main:<span class="number">8</span>********main()*********</span><br></pre></td></tr></table></figure>


<h2 id="2-创建线程的方式二：实现Runnable接口的方式"><a href="#2-创建线程的方式二：实现Runnable接口的方式" class="headerlink" title="2.创建线程的方式二：实现Runnable接口的方式"></a>2.创建线程的方式二：实现Runnable接口的方式</h2><p>使用方法：</p>
<ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()，启动线程  </li>
<li>实现Runnable和继承Thread方式的对比：<br>开发中：优先选择：实现Runnable接口的方式  </li>
</ol>
<p>原因：</p>
<ol>
<li>实现接口的方式没有类的单继承性的局限性<ol start="2">
<li>实现的方式更适合来处理多个线程共享数据的情况。  </li>
</ol>
</li>
</ol>
<ul>
<li>例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        MThread m = <span class="keyword">new</span> MThread();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(m,<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//再启动一个线程，遍历10以内偶数</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(m,<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程二:<span class="number">0</span></span><br><span class="line">线程二:<span class="number">2</span></span><br><span class="line">线程二:<span class="number">4</span></span><br><span class="line">线程二:<span class="number">6</span></span><br><span class="line">线程一:<span class="number">0</span></span><br><span class="line">线程二:<span class="number">8</span></span><br><span class="line">线程一:<span class="number">2</span></span><br><span class="line">线程一:<span class="number">4</span></span><br><span class="line">线程一:<span class="number">6</span></span><br><span class="line">线程一:<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建线程的方式三：实现Callable接口的方式-—-jdk5-0新增"><a href="#3-创建线程的方式三：实现Callable接口的方式-—-jdk5-0新增" class="headerlink" title="3.创建线程的方式三：实现Callable接口的方式 —- jdk5.0新增"></a>3.创建线程的方式三：实现Callable接口的方式 —- jdk5.0新增</h2><p>使用方法<br> 1.创建一个实现Callable接口的实现类<br> 2.重写call方法，将此线程需要执行的操作声明在call（）中<br> 3.创建Callable接口实现类的对象<br> 4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象<br> 5.将FutureTask的对象作为参数传入Thread类的构造器中，创建Thread对象，并调用start（）方法。<br> 6.还可以使用FutureTask对象的get()方法获取Callable中的call方法的返回值，不需要返回值的话，在重写的call（）方法里返回null即可</p>
<p>  如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</p>
<ol>
<li>call()方法是可以有返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的  </li>
</ol>
<p>例子：创建一个以实现Callable方式的线程，内部计算1到100的所有偶数的和  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//2.重写call方法，将此线程需要执行的操作声明在call（）中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread n = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(n);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传入Thread类的构造器中，创建Thread对象，并调用start（）方法。</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中的call方法的返回值</span></span><br><span class="line">            <span class="comment">//get方法返回值即为futureTask构造器参数Callable实现类重写的call（）方法的返回值</span></span><br><span class="line">            Integer res = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为&quot;</span>+res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：总和为2550</span></span><br></pre></td></tr></table></figure>

<h2 id="创建线程池的方式之四：创建线程池Executor"><a href="#创建线程池的方式之四：创建线程池Executor" class="headerlink" title="创建线程池的方式之四：创建线程池Executor"></a>创建线程池的方式之四：创建线程池Executor</h2><p>好处：<br>1.提高响应速度（减少了创建新线程的时间）<br>2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3.便于线程管理<br>corePoolSize：核心池的大小<br>maximumPoolSize：最大线程数<br>keepAliveTime：线程没任务时最多保持多长时间后会终止</p>
<p>主要有三种 Executor：</p>
<p>CachedThreadPool：一个任务创建一个线程；<br>FixedThreadPool：所有任务只能使用固定大小的线程；<br>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立MyRunnable类实现Runnable并在run()内添加需要的业务逻辑即可，这里省略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程的生命周期和优先级"><a href="#线程的生命周期和优先级" class="headerlink" title="线程的生命周期和优先级"></a>线程的生命周期和优先级</h1><p>生命周期：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9iMDJiNjU0Mzk3YjE3YTE5OWFhMDI3MjdiNmVkNjVkZjBkZDRlZTE5LzY4NzQ3NDcwNzMzYTJmMmY2OTZkNjcyZDYyNmM2ZjY3MmU2MzczNjQ2ZTY5NmQ2NzJlNjM2ZTJmMzIzMDMxMzgzMTMwMzMzMTMxMzAzNTM2MzIzNzM0MzMzNzJlNzA2ZTY3M2Y3ODJkNmY3MzczMmQ3MDcyNmY2MzY1NzM3MzNkNjk2ZDYxNjc2NTJmNzc2MTc0NjU3MjZkNjE3MjZiMmM3NDc5NzA2NTVmNWE2ZDQ2NzU1YTMzNzA2ZjVhNTczNTZlNjE0NzU2NzA2NDQ3NmIyYzczNjg2MTY0NmY3NzVmMzEzMDJjNzQ2NTc4NzQ1ZjYxNDg1MjMwNjM0ODRkMzY0Yzc5Mzk2OTYyNDczOTZlNGM2ZDRlN2E1YTQ3MzQ3NTYyNmQ1NjMwNGMzMzcwNmY2MjMzNTUzNTRkNmE0MTMzNGY0NDU5N2E0ZDU0NDkzZDJjNzM2OTdhNjU1ZjMxMzYyYzYzNmY2YzZmNzI1ZjQ2NDY0NjQ2NDY0NjJjNzQ1ZjM3MzA?x-oss-process=image/format,png" alt="线程的状态转换"><br>状态</p>
<ul>
<li>new（新建）</li>
<li>runnnable（就绪）</li>
<li>blocked（阻塞）</li>
<li>waiting（等待）</li>
<li>time waiting （定时等待）</li>
<li>terminated（终止)  </li>
</ul>
<p>线程状态流程如下：</p>
<ul>
<li>线程创建后，进入 new 状态</li>
<li>调用 start 方法，进入 runnable 状态</li>
<li>JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，执行run()方法并进入 running 状态</li>
<li>如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态</li>
<li>线程执行完毕后，线程被线程队列移除。最后为 terminated 状态          </li>
</ul>
<h1 id="线程的同步方法"><a href="#线程的同步方法" class="headerlink" title="线程的同步方法"></a>线程的同步方法</h1><h2 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h2><p>优点：线程安全但是效率较低<br>注意：同步监视器必须是独一无二的唯一对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">   <span class="comment">//需要被同步的代码...  </span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常经典的例子：卖票。<br>创建三个窗口卖票，总票数为10张，使用实现Runnable接口的方式。<br>若不加同步：卖票过程中，可能出现重票、错票的线程安全问题。<br>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来。<br>这里就用同步代码块来实现。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window1 w = <span class="keyword">new</span> Window1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，票号为&quot;</span>+tickets);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：没有重票，错票的情况。</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为10</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为9</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为8</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为7</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为6</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为5</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为4</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为3</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为2</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为1</span></span><br></pre></td></tr></table></figure>




<h2 id="方式二：声明同步方法"><a href="#方式二：声明同步方法" class="headerlink" title="方式二：声明同步方法"></a>方式二：声明同步方法</h2><p>在需要同步的操作共享资源的方法上添加synchronized关键字<br>同样是卖票的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window3 w = <span class="keyword">new</span> Window3();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//同步监视器：this</span></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，票号为&quot;</span>+tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口一卖票，票号为10</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为9</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为8</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为7</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为6</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为5</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为4</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为3</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为2</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为1</span></span><br></pre></td></tr></table></figure>


<h2 id="方式三：JUC的lock工具"><a href="#方式三：JUC的lock工具" class="headerlink" title="方式三：JUC的lock工具"></a>方式三：JUC的lock工具</h2><p>主要学习的是java.util.concurrent.locks.ReentrantLock<br>使用方式：进入操作共享数据逻辑之前，使用lock.lock()为线程加锁（假设实例化的ReentrantLcok对象名为lock），操作共享数据结束后释放锁：lock.unlock()，具体例子如下(这里使用了匿名内部类简化线程的创建)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    ticket.sale_ticket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;一&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ticket.sale_ticket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;二&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ticket.sale_ticket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;三&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets_number = <span class="number">10</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sale_ticket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(tickets_number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;卖第&quot;</span>+tickets_number--+<span class="string">&quot;张票，还剩&quot;</span> + tickets_number  + <span class="string">&quot;张票&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//线程一卖第10张票，还剩9张票</span></span><br><span class="line"><span class="comment">//线程一卖第9张票，还剩8张票</span></span><br><span class="line"><span class="comment">//线程一卖第8张票，还剩7张票</span></span><br><span class="line"><span class="comment">//线程一卖第7张票，还剩6张票</span></span><br><span class="line"><span class="comment">//线程二卖第6张票，还剩5张票</span></span><br><span class="line"><span class="comment">//线程一卖第5张票，还剩4张票</span></span><br><span class="line"><span class="comment">//线程三卖第4张票，还剩3张票</span></span><br><span class="line"><span class="comment">//线程一卖第3张票，还剩2张票</span></span><br><span class="line"><span class="comment">//线程三卖第2张票，还剩1张票</span></span><br><span class="line"><span class="comment">//线程一卖第1张票，还剩0张票</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Vorherige Seite"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Nächste Seite"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Stephen Jia</p>
  <div class="site-description" itemprop="description">Try Everything......</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">schlagwörter</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Jia</span>
</div>
  <div class="powered-by">Erstellt mit  <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
