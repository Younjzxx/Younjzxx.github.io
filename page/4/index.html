<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiazx.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Try Everything......">
<meta property="og:type" content="website">
<meta property="og:title" content="J Blog">
<meta property="og:url" content="http://jiazx.top/page/4/index.html">
<meta property="og:site_name" content="J Blog">
<meta property="og:description" content="Try Everything......">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Stephen Jia">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiazx.top/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>J Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">J Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-10/" class="post-title-link" itemprop="url">实现用户访问某个模块按权限拦截的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:06:25 / 修改时间：17:06:41" itemprop="dateCreated datePublished" datetime="2020-08-16T17:06:25+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="思路一：自定义注解-spring-intercepter方式"><a href="#思路一：自定义注解-spring-intercepter方式" class="headerlink" title="思路一：自定义注解+spring intercepter方式"></a>思路一：自定义注解+spring intercepter方式</h1><h2 id="1-定义一个Permission注解"><a href="#1-定义一个Permission注解" class="headerlink" title="1.定义一个Permission注解"></a>1.定义一个Permission注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Permission &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解一般会打到controller层的api方法上面。value代表了这个api需要的权限，也可以设计成Integer类型的代表需要的权限level，whatever，这个地方可以根据需要自己设计。</p>
<h2 id="2-编写intercepter"><a href="#2-编写intercepter" class="headerlink" title="2.编写intercepter"></a>2.编写intercepter</h2><p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将拦截器注册到spring容器</span></span><br><span class="line"><span class="comment">//开始编写拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//返回true即代表放过请求，返回false即代表拦截请求</span></span><br><span class="line">    <span class="comment">//根据Permission判断是否该放过请求</span></span><br><span class="line">    <span class="comment">//1.将handler强转为方法的handler</span></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    <span class="comment">//2.获取这个api方法上面的注解</span></span><br><span class="line">    Permission permissionValue = handlerMethod.getMethod().getAnnotation(Permission.class);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//3.如果方法上没有Permission注解，代表这个api不需要权限，放过请求</span></span><br><span class="line">     <span class="keyword">if</span> (permissionValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="comment">//4.如果获取到了非空的Permission注解，那么就判断是否有权限就好啦</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNotBlank(permissionValue.value())) &#123;</span><br><span class="line">        <span class="comment">//把permissionValue.value()获取到后去判断权限，判断的方法可以自己设计，可以将考虑将各种权限信息设计到一个sql table里面！</span></span><br><span class="line">        <span class="keyword">if</span>(符合权限)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">//不符合权限，拦截，可以考虑抛个异常打个日志什么的，也可以考虑返给前端一个不符合权限的信息</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="思路二：用-Aspect切面实现拦截"><a href="#思路二：用-Aspect切面实现拦截" class="headerlink" title="思路二：用@Aspect切面实现拦截"></a>思路二：用@Aspect切面实现拦截</h1><p>//TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-9/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记八：使用Redis实现分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:05:32 / 修改时间：17:06:42" itemprop="dateCreated datePublished" datetime="2020-08-16T17:05:32+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>因为应用程序服务器有两台，所以如果仅仅在每台机器上面同步时不够的，因为获取到的不是同一把锁。</p>
<p>这里使用redis实现分布式锁</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>使用redis作为分布式锁要注意几点：</p>
<p>原理：在redis上面定义一个锁的key，每台应用程序服务器的下单请求先要去redis尝试创建一个锁的key，如果锁的key已经存在，那么说明其他线程已经进入，这个线程就阻塞。如果锁的key不存在，那么就说明锁是可以获取的状态，建立这个key从而获取锁。</p>
<p>注意事项一：产生异常情况如何保证锁的释放<br>答：利用try finally，try里面放下单流程，finally里面删除key，保证异常情况下也能释放锁。</p>
<p>注意事项二：服务器断电之后，锁一直存在怎么办？<br>答：设置过期时间，注意！redis的2.6之前的版本，设置锁的key、设置过期时间这两步操作不是原子性的！但是在2.6之后，可以用一行代码设置key并设置过期时间保证原子性。下面会介绍。</p>
<p>注意事项三：如何保证线程释放的是自己加上的锁？<br>答：加锁的key的时候，value设置为一个随机的uuid，等到删除key的时候，先判断缓存中value是不是这个uuid，如果是再释放。</p>
<p>注意事项四：程序执行时间过长，超过了key的过期时间怎么办？<br>开一个守护线程，先休眠，然后不断去判断当前线程是否还有持有锁，如果持有而且超时时间到，就给他“续命”，加上一段时间，直到线程自己删掉key释放锁。</p>
<h1 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h1><p>因为我的redis只有一台，如果redis也部署了主从，那么无法完全保证可靠性。因为分布式锁只会去验证主redis的加锁情况。而不会去验证从redis的key的情况。<br>但是zookeeper是有全部主从分布式锁的验证的，所以zookeeper比较能保证安全，但是相对于redis的实现方式效率较低。</p>
<p>redis实现的方式可以使用redisson框架直接实现</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这里以减库存为例，方式超卖现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">       <span class="comment">//int affectedRow = itemStockDOMapper.decreaseStock(itemId, amount);</span></span><br><span class="line">       <span class="comment">//result是代表执行完扣减库存操作之后的结果（还剩多少）</span></span><br><span class="line">       String lockValue = UUID.randomUUID().toString();</span><br><span class="line">       Boolean lockSuccess = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lockKey&quot;</span>, lockValue, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">if</span>(lockSuccess)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> result = redisTemplate.opsForValue().increment(<span class="string">&quot;kill_item_stock&quot;</span>+itemId, amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//更新库存成功</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//更新库存失败</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(redisTemplate.opsForValue().get(<span class="string">&quot;lockKey&quot;</span>).equals(lockValue))&#123;</span><br><span class="line">                   redisTemplate.delete(<span class="string">&quot;lockKey&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-8/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记七：nginx lua脚本实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:04:27 / 修改时间：17:05:10" itemprop="dateCreated datePublished" datetime="2020-08-16T17:04:27+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、nginx为什么高性能"><a href="#一、nginx为什么高性能" class="headerlink" title="一、nginx为什么高性能"></a>一、nginx为什么高性能</h1><h2 id="epoll多路复用"><a href="#epoll多路复用" class="headerlink" title="epoll多路复用"></a>epoll多路复用</h2><p>1.传统模型：基于缓冲区的传输<br>首先，假设这里有两台主机进行通信<br>client —– server<br>当client要向server传输数据的时候:数据不会直截了当地发到server处，而是先进行一个socket.write操作，并将要发送的数据包放到<strong>缓冲区</strong>中。<br>如果有一个数据包要发送，这时候缓冲器被占满了，那么tcp/ip会先将缓冲区里面的数据全部传输完成，才能让新的数据包进入缓冲区，然后再进入服务器。这样的操作效率不够高</p>
<p>2.linux select模型：变更触发轮询查找<br>select多路复用是server阻塞自己的同时监听多个客户端的连接，一旦有连接发生变化，那么就唤醒自己，循环遍历100个连接，找到发生变化的一个或者多个，执行read操作。缺陷：遍历的效率很低，并且有1024的数量上限</p>
<p>3.epoll多路复用模型：根据回调函数唤醒自己<br>同样，server阻塞自己同时监听多个客户端的连接。并且设置回调函数。若发生变化直接唤醒自己执行回调函数。</p>
<h2 id="master-worker进程模型"><a href="#master-worker进程模型" class="headerlink" title="master-worker进程模型"></a>master-worker进程模型</h2><p>启动nginx之后，会产生一个nginx的master进程，这个master可以产生多个worker进程，通过ps -ef | grep nginx可以看到：nginx启动了两种进程，一个是master process，一个worker process，并且可以发现master是worker的父进程。也就是说master进程可以管理一切worker进程中的内存，堆栈，函数……<br>而worker进程就是真正的处理多个客户端连接的一个进程，也就是客户端的请求是由worker进程去连接和管理的，而在并发情景下，nginx设置了<strong>内存中的锁</strong>，worker进程抢占锁的速度就会很快。并且每个worker进程是<strong>单线程的</strong>，进程的内部没有任何多线程的阻塞所以效率很高。</p>
<h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><p>1.协程是比线程更小的一个概念，一个线程可以有多个协程，协程之间的切换不是cpu管理的，而是在<strong>内存中切换</strong>，切换开销非常小。<br>2.协程遇到阻塞归还执行权给其他协程，代码自动同步，无需手动处理，无需加锁。</p>
<h1 id="二、开始优化"><a href="#二、开始优化" class="headerlink" title="二、开始优化"></a>二、开始优化</h1><p>1.第一尝试了配置nginx的proxy cache，第一次拿到热点数据之后将数据存储在nginx服务器上，下一次就从nginx获取，这样反而变慢了，tps在1200左右，这是因为<strong>nginx的proxy cache不是在内存中的，而是在磁盘中的！</strong>，所以他的性能反而不如再去tomcat服务器的内存里面获取快一些。</p>
<p>2.第二次尝试编写lua脚本,配置shared dictionary<br>nginx的shared dictionary，顾名思义就是共享字典，他是所有worker进程可见的，并且具有lru淘汰策略，最重要的是它将数据存储在内存中。</p>
<p>配置shared dictionary：</p>
<ul>
<li>打开nginx.conf<br>添加以下内容</li>
<li>*lua_shared_dict my_cache 128m;**<br>这一行的作用是给shared dictionary分配内存大小</li>
</ul>
<p>location处添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /luaitem/get&#123;</span><br><span class="line">    default_type <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">    content_by_lua_file = ../lua/itemshareddic.lua;</span><br></pre></td></tr></table></figure>



<ul>
<li>进入nginx的lua文件夹，编写itemshareddic.lua</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> get_from_cache(key)</span><br><span class="line">    <span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">    <span class="built_in">local</span> value = cache_ngx:get(key)</span><br><span class="line">    <span class="built_in">return</span> value</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> set_to_cache(key, value,exptime)</span><br><span class="line">    <span class="keyword">if</span> not exptime <span class="keyword">then</span></span><br><span class="line">        exptime = 0</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">    <span class="built_in">local</span> succ,err,forcible = cache_ngx:<span class="built_in">set</span>(key,value,exptime)</span><br><span class="line">    <span class="built_in">return</span> succ</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> id = args[<span class="string">&quot;id&quot;</span>]</span><br><span class="line"><span class="built_in">local</span> item_model = get_from_cache(<span class="string">&quot;item_&quot;</span>..id)</span><br><span class="line"><span class="keyword">if</span>(item_model == nil) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">local</span> resp = ngx.location.capture(<span class="string">&quot;/item/get?id=&quot;</span>..id)</span><br><span class="line">    item_model = resp.body</span><br><span class="line">    set_to_cache(<span class="string">&quot;item_&quot;</span>..id,item_model,1*60)</span><br><span class="line">end</span><br><span class="line">ngx.say(item_model)</span><br></pre></td></tr></table></figure>

<h1 id="三、继续优化"><a href="#三、继续优化" class="headerlink" title="三、继续优化"></a>三、继续优化</h1><p>上面的优化是非常吃内存的，最大的缺陷更新不方便，所以这里继续配置openresty 的 redis支持，即将nginx服务器连接到redis数据库上面，可以只读不写。若redis没有对应的数据，那么就回到应用程序服务器上面去获取并存入redis，那么下一次ajax请求到达nginx服务器处，就直接从redis上面进行读的操作。甚至可以直接设立一个slave的redis，只负责读操作。</p>
<p>进入nginx服务器，打开lua文件夹，新建一个itemredis.lua</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> id = args[<span class="string">&quot;id&quot;</span>]</span><br><span class="line"><span class="built_in">local</span> redis = require <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="built_in">local</span> cache = redis:new()</span><br><span class="line"><span class="built_in">local</span> ok,err = cache:connect(<span class="string">&quot;redis服务器的ip&quot;</span>,端口号)</span><br><span class="line"><span class="built_in">local</span> item_model = cache:get(<span class="string">&quot;item_&quot;</span>..id)</span><br><span class="line"><span class="keyword">if</span> item_model == ngx.null or item_model == nil <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">local</span> resp = ngx.location.capture(<span class="string">&quot;/item/get?id=&quot;</span>..id)</span><br><span class="line">    item_model = resp.body</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(item_model)</span><br></pre></td></tr></table></figure>

<p>打开nginx.conf<br>将上一个步骤中配置的location从itemshareddic.lua改为itemredis.lua<br>重启nginx服务即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-7/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记六：商品详情信息缓存策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:03:45 / 修改时间：17:04:22" itemprop="dateCreated datePublished" datetime="2020-08-16T17:03:45+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、商品详情页面缓存"><a href="#一、商品详情页面缓存" class="headerlink" title="一、商品详情页面缓存"></a>一、商品详情页面缓存</h1><p>商品详情页面存入redis缓存中<br>获取商品详情controller接口方法更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据商品详情页的id到redis内获取,实现这个功能需要序列化itembo以及itembo内部聚合的killbo</span></span><br><span class="line">            itemBO = (ItemBO) redisTemplate.opsForValue().get(<span class="string">&quot;item_&quot;</span> + id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若redis内不存在对应的itembo，则访问下游的service,去数据库取</span></span><br><span class="line">            <span class="keyword">if</span>(itemBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//只进一次service获取mysql数据库数据</span></span><br><span class="line">                itemBO = itemService.getItemById(id);</span><br><span class="line">                <span class="comment">//存到redis，并且存到redis内，设置上过期时间10分钟，第二次刷新之后的十分钟都从redis获取</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;item_&quot;</span>+id, itemBO);</span><br><span class="line">                redisTemplate.expire(<span class="string">&quot;item_&quot;</span>+id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>修改key - value的序列化方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//首先解决key的序列化方式，最简单的string即可</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决value的序列化方式</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">        simpleModule.addSerializer(DateTime.class, <span class="keyword">new</span> JodaDateTimeJsonSerializer());</span><br><span class="line">        simpleModule.addDeserializer(DateTime.class, <span class="keyword">new</span> JodaDateTimeJsonDeserializer());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使缓存包含类的信息        </span></span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        objectMapper.registerModule(simpleModule);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写datetime格式数据的序列化和反序列化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JodaDateTimeJsonSerializer</span>  <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">DateTime</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        jsonGenerator.writeString(dateTime.toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JodaDateTimeJsonDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">DateTime</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext deserializationContext)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        String dateString = jsonParser.readValueAs(String.class);</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormat.forPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DateTime.parse(dateString, formatter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署，压测：<br>cpu-H<br>redis占用2%左右<br>平均响应时间300ms左右<br>tps最高2000+</p>
<h1 id="二、使用guava设计多级缓存策略"><a href="#二、使用guava设计多级缓存策略" class="headerlink" title="二、使用guava设计多级缓存策略"></a>二、使用guava设计多级缓存策略</h1><p>其实设计这个步骤的初衷是将商品模型直接存储在jvm中在一段时间内持久保存，首先考虑的是将商品模型做成一个HashMap，并让这个HashMap进行商品详情的缓存。但是这样做首先会有多线程的问题，不支持并发读写的问题。若改用ConcurentHashMap是基于段的方式加锁，在写锁加上去之后，会对读的性能有很大影响，并且还要考虑失效时间和淘汰机制这些复杂的内容，所以单纯的ConcurentHashMap非常复杂。<br>所以这里选用谷歌的guava cache来实现热点数据的缓存。</p>
<p>1.导入guava cache依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--guava将热点数据存入jvm内存中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.写CommonCache接口和实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装本地缓存操作类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取方法</span></span><br><span class="line">    <span class="function">Object <span class="title">getCommonCache</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, Object&gt; commonCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//commonCache设置的方法是一串设置方法的实现，最后.build()来创建commonCache</span></span><br><span class="line">        commonCache = CacheBuilder.newBuilder()</span><br><span class="line">                <span class="comment">//设置缓存容器的初始容量为10</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//设置缓存中最大存储100个key，超过100个之后会按照lru的策略移除缓存项</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">//设置写缓存之后多少秒过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        commonCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在获取商品详情的controller接口再次更改获取model的方式<br>1.先从guava cache取，没有去redis取，再没有去service层（mysql）取。<br>2.若redis有，存入guava cache；若service有，存入redis，存入guava cache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品详情页的浏览，（浏览功能一般用get请求）</span></span><br><span class="line">   <span class="meta">@GetMapping(value = &quot;/get&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(<span class="meta">@RequestParam(name = &quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">       ItemBO itemBO = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先取本地缓存</span></span><br><span class="line">       itemBO = (ItemBO) cacheService.getCommonCache(<span class="string">&quot;item_&quot;</span>+id);</span><br><span class="line">       <span class="comment">//本地缓存不存在，去redis找</span></span><br><span class="line">       <span class="keyword">if</span>(itemBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//根据商品详情页的id到redis内获取,实现这个功能需要序列化itembo以及itembo内部聚合的killbo</span></span><br><span class="line">           itemBO = (ItemBO) redisTemplate.opsForValue().get(<span class="string">&quot;item_&quot;</span> + id);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//若redis内不存在对应的itembo，则访问下游的service,去数据库取</span></span><br><span class="line">           <span class="keyword">if</span>(itemBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">               itemBO = itemService.getItemById(id);</span><br><span class="line">               <span class="comment">//存到redis，并且存到redis内，加上过期时间</span></span><br><span class="line">               redisTemplate.opsForValue().set(<span class="string">&quot;item_&quot;</span>+id, itemBO);</span><br><span class="line">               redisTemplate.expire(<span class="string">&quot;item_&quot;</span>+id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//从redis获取完之后，将数据保存到本地缓存之中,填充本地缓存</span></span><br><span class="line">           cacheService.setCommonCache(<span class="string">&quot;item_&quot;</span>+id, itemBO);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>guava cache可以方便的控制cache的大小和存活时间，而且可以配置淘汰策略，并且线程安全。</p>
<p>压测：<br>这次效果出现了飞跃式的增长：<br>cpu-H 数据库服务器的cpu基本无压力<br>响应时间：150ms左右<br>tps:3200左右</p>
<p>不用再经过反向代理服务器–&gt;tomcat服务器–&gt;redis/mysql这个繁杂的过程，直接去tomcat服务器一层的jvm里面取数据，减少了一段网络开销。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-6/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记五：分布式扩展之后的分布式session问题解决</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:02:35 / 修改时间：17:03:47" itemprop="dateCreated datePublished" datetime="2020-08-16T17:02:35+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="项目添加redis的session依赖"><a href="#项目添加redis的session依赖" class="headerlink" title="项目添加redis的session依赖"></a>项目添加redis的session依赖</h1><p>将分布式session存储在redis内：<br>打开项目的pom.xml，导入springboot对reids的依赖</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>添加如下依赖之后，可以增加一个配置类配置session存活时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)</span><span class="comment">//session存活一小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据库服务器安装redis4-0-1"><a href="#数据库服务器安装redis4-0-1" class="headerlink" title="数据库服务器安装redis4.0.1"></a>数据库服务器安装redis4.0.1</h1><p>我这里数据库服务器只有一台，而应用程序服务器是多台的，所以会出现分布式的session获取不到的问题，这里将redis安装到唯一的数据库服务器中。</p>
<p>官网下载redis-4.0.1.tar.gz，放到服务器：<br>执行：<br>chmod - R 777 redis-4.0.1.tar.gz<br>tar -xvzf redis-4.0.1.tar.gz<br>cd redis-4.0.1<br>make<br>make install<br>cd src<br>./redis-server &amp;<br>./redis-cli<br>安装并启动redis</p>
<h1 id="本地部署测试"><a href="#本地部署测试" class="headerlink" title="本地部署测试"></a>本地部署测试</h1><p>修改application.properties:<br>增加redis配置</p>
<p>#配置springboot对redis的依赖<br>spring.redis.host=127.0.0.1 # 这里之后还要修改<br>spring.redis.port=6379<br>spring.redis.database=10<br>#spring.redis.password=</p>
<p>#设置jedis连接池<br>spring.redis.jedis.pool.max-active=50<br>spring.redis.jedis.pool.min-idle=20</p>
<p>将用户登录的session模型类实现Serializable使redis可以序列化</p>
<p>之后测试登录：<br>登录成功</p>
<p>踩坑：<br>但是……坑爹的来了，测试获取验证码失败。<br>一步一步debug：发现redis内有数据，key也是正确的，<strong>但是获取却一直为null。</strong><br>因为我的验证码的获取和用户输入是两个不同的页面，所以为了安全起见，session默认会被获取为null。<br><strong>查阅资料得出，如果满足以下几点，session可能获取为null。</strong></p>
<ul>
<li>使用了springboot2.x，并且前后端资源是跨域的。</li>
<li>获取session的请求接口是post方式发送的</li>
<li>存储session和取得session是不同的两个页面。</li>
</ul>
<p>满足以上三点，session的获取就会为null；<br>解决方案，编写配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringSessionConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">httpSessionIdResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">// 取消仅限同一站点设置</span></span><br><span class="line">        cookieSerializer.setSameSite(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功完成session跨页获取<br>至此为止，分布式session的问题被解决。不会出现用户登录失效的问题。</p>
<h1 id="token方式替代基于cookie传递sessionId"><a href="#token方式替代基于cookie传递sessionId" class="headerlink" title="token方式替代基于cookie传递sessionId"></a>token方式替代基于cookie传递sessionId</h1><p>项目代码中修改，将传统session方式替代。这样的好处是可以使用多个平台的兼容性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//生成登录凭证token，每个用户不重复的uuid</span></span><br><span class="line">        String uuidToken = UUID.randomUUID().toString();</span><br><span class="line">        uuidToken = uuidToken.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//建立token和登陆之后用户模型之间的联系</span></span><br><span class="line">        redisTemplate.opsForValue().set(uuidToken, userBO);</span><br><span class="line">        <span class="comment">//设置超时时间一个小时</span></span><br><span class="line">        redisTemplate.expire(uuidToken,<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"><span class="comment">//        //将登录凭证加入到用户登陆成功的session</span></span><br><span class="line"><span class="comment">//        this.httpServletRequest.getSession().setAttribute(&quot;IS_LOGIN&quot;, true);</span></span><br><span class="line"><span class="comment">//        this.httpServletRequest.getSession().setAttribute(&quot;LOGIN_USER&quot;, userBO);</span></span><br><span class="line">        <span class="comment">//下发token</span></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(uuidToken);</span><br></pre></td></tr></table></figure>

<p>前端判断登录成功之后存储token的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = data.data;</span><br><span class="line"><span class="comment">//html5新出的token方式localStorage，比cookie session安全且没有容量限制</span></span><br><span class="line"><span class="built_in">window</span>.localStorage[<span class="string">&quot;token&quot;</span>]=token;</span><br></pre></td></tr></table></figure>

<p>需要验证用户登录信息时，验证token是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = <span class="built_in">window</span>.localStorage[<span class="string">&quot;token&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span>(token == <span class="literal">null</span>)&#123;</span><br><span class="line">                alert(<span class="string">&quot;没有登录，不能下单！&quot;</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.href=<span class="string">&quot;login.html&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>后端负责验证token信息是否正确，并从token获取用户模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String token = httpServletRequest.getParameterMap().get(<span class="string">&quot;token&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN,<span class="string">&quot;用户还未登录，不能下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取用户登录信息</span></span><br><span class="line">        UserBO userBO = (UserBO) redisTemplate.opsForValue().get(token);</span><br><span class="line">        <span class="keyword">if</span>(userBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN,<span class="string">&quot;用户还未登录，不能下单&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了将token放到ajax请求的url中（参数拼上?token=”+token）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//登录成功之后，将用户模型存入前台的localStorage</span><br><span class="line">            var token = data.data;</span><br><span class="line">//html5新出的token方式localStorage，比cookie session安全且没有容量限制</span><br><span class="line">            window.localStorage[&quot;token&quot;]=token;</span><br><span class="line">//....................................................................</span><br><span class="line">            var token = window.localStorage[&quot;token&quot;];//从前台localStorage获取token</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                url: &quot;http://&quot;+g_host+&quot;/order/createorder?token=&quot;+token,</span><br><span class="line">                contentType: &quot;application/x-www-form-urlencoded&quot;,</span><br></pre></td></tr></table></figure>

<p>本地调试成功之后，部署到云端的数据库服务器中，因为我这里暂时还没有主从服务器，只有一台数据库服务器，所以把redis安装在了mysql数据库服务器中，两者共用一台服务器。</p>
<p>将两台应用程序服务器的application.properties都修改，增加如下的配置：<br>spring.redis.host=数据库服务器的私网ip。<br>之后重新启动两个应用程序jar包，调试，成功。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>这篇文章主要解决的问题是：<br>用户登录信息的session经过分布式扩展之后可能获取不到的问题，从基于cookie传递sessionID的方式转化为基于token传输类似于sessionID的形式，并且使session迁移至公共的redis数据库中。</p>
<p>解决方式：<br>通过redis集中式缓存sessionID。并通过redisTemplate.opsForValue().set(uuidToken, userBO);实现session的存取。<br>UserBO userBO = (UserBO) redisTemplate.opsForValue().get(token);实现session的获取。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-5/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记四：nginx反向代理优化，分布式扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:02:12 / 修改时间：17:03:35" itemprop="dateCreated datePublished" datetime="2020-08-16T17:02:12+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先我们需要思考上一个章节并发上不去的原因。发现在并发环境下mysql数据库的压力始终很大，一台服务器上面不仅仅要跑java的jar包程序，还要承受高并发访问数据库的压力。这样的压力都在同一台服务器上显然存在缺陷。所以我们可以购买多台服务器。</p>
<p>一台专门用来部署项目的数据库。<br>两台或多台用来部署项目jar包。<br>一台用来配置部署nginx反向代理。</p>
<p>首先这里购买4台服务器，两台跑java，一台部署数据库，一台部署nginx。</p>
<p>部署前准备：<br>将原来的  //var/www项目文件夹传输至另两台需要部署jar包的服务器中,原来的服务器就用来部署mysql数据库。</p>
<p>使用scp：<br><strong>scp  -r   //var/www  root@目标服务器ip地址:/var</strong>，然后输入密码即可。<br>这里如果购买的多台服务器都是阿里云的同一地区的服务器，用私有ip进行传输，因为阿里云同一地区的服务器是内网互通的，互相传输快的飞起。</p>
<p>分别将www内的项目文件传输完成之后。准备在两台服务器上面配置数据库连接并启动。</p>
<h1 id="应用程序服务器（两台）"><a href="#应用程序服务器（两台）" class="headerlink" title="应用程序服务器（两台）"></a>应用程序服务器（两台）</h1><p>先在两台应用程序服务器上rpm安装jdk，之前的笔记中有操作流程这里不再赘述。<br>切换到项目www/seckill目录准备启动项目。在把jar包跑起来之前，先要将接收到的配置文件修改一下，因为，项目中的application.properties文件默认的datasource.url是localhost:3306。如果这样启动起来，是找不到数据库的，因为应用程序服务器并不是用来部署数据库的，所以，我们打开外挂的配置文件修改datasource：<br>vim application.properties.<br>添加下面一行配置：<br><strong>spring.datasource.url=jdbc:mysql://数据库服务器的内网ip:3306/seckillboot?serverTimezone=GMT%2B8</strong><br>数据库服务器的内网地址即刚刚传输项目的服务器，<strong>必须用内网ip保证数据库访问速度</strong>。</p>
<p>配置好DataSource之后，在启动项目之前，测试能否连接上数据库的服务器：<br><strong>yum install telnet</strong><br><strong>telnet  数据库服务器ip  3306</strong><br>结果发现，远程数据库拒绝了连接。<br>这时候我们要去数据库服务器配置mysql的远程连接权限（见第二部分）。<br>配置好之后再次telnet ip:3306测试连接，提示输入数据库密码即可连接，这里就不连了，直接 <strong>./deploy.sh &amp;</strong> 启动项目即可。<br>启动项目之后，访问 <strong>项目服务器公有ip/可以访问数据库的路径，我的是ip/item/get?id=9，可以显示出从数据库获取的item数据，表示部署成功（两台服务器操作相同）</strong></p>
<h1 id="数据库服务器"><a href="#数据库服务器" class="headerlink" title="数据库服务器"></a>数据库服务器</h1><h2 id="配置其他服务器连接数据库的权限"><a href="#配置其他服务器连接数据库的权限" class="headerlink" title="配置其他服务器连接数据库的权限"></a>配置其他服务器连接数据库的权限</h2><p>只要知道数据库的root的密码就可以有全部数据库的全部权限,最后刷新权限，无需重启数据库，可以这样配置。<br><strong>mysql -uroot -p密码<br>grant all privileges on *.* to root@’%’ identified by ‘root’;</strong><br><strong>flush privileges;</strong></p>
<p>这时，到应用程序服务器上就可以访问到数据库服务器的数据库。<br>下面是nginx反向代理服务器的配置。</p>
<h1 id="nginx反向代理服务器"><a href="#nginx反向代理服务器" class="headerlink" title="nginx反向代理服务器"></a>nginx反向代理服务器</h1><p>在部署nginx的服务器上安装openresty：<br>1.下载openresty并上传到部署nginx的服务器。<br>2.chomd -R 777授予权限，<strong>tar -xvzf  包名</strong>  安装解压。<br>3.cd 解压后的openresty目录。<br>4.   执行 <strong>./configure</strong>（需要先yum install gcc）<br>5. <strong>make</strong>编译完成之后，<strong>make install</strong><br>6. <strong>cd //user/local/openresty</strong>进入openresty目录。<br>7. 在nginx目录下，cd ls直到出现conf  html  logs  sbin四个文件夹。在这个目录下执行<strong>sbin/nginx -c conf/nginx.conf 启动nginx</strong>，配置文件的主要参数：<br>location节点path：指定url映射key<br>location节点内容：root指定location path后对应的根路径，index指定默认的访问页。<br><strong>重启nginx的命令</strong>为：<strong>sbin/nginx -s reload</strong></p>
<p>8.启动nginx之后访问服务器ip会显示openresty的成功页。<br>至此nginx安装部署完成。</p>
<h1 id="将前端资源部署到nginx上。"><a href="#将前端资源部署到nginx上。" class="headerlink" title="将前端资源部署到nginx上。"></a>将前端资源部署到nginx上。</h1><p>1.将本地的html文件上传到服务器的：/usr/local/openresty/nginx/html路径下，并命名为resources文件夹。<br>2.vim编辑/usr/local/openresty/nginx/conf路径下的nginx.conf文件修改前端路由配置。<br>3.修改如下区域的配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">location /resources/&#123;</span><br><span class="line">    <span class="built_in">alias</span>  /usr/<span class="built_in">local</span>/openresty/nginx/html/resources/;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即如果输入的路径地址包括了/resources下，那么就会自动去/usr/local/openresty/nginx/html/resources/这个alias路径下寻找资源，并且将对应名字的html资源拼接在后面，也就是说alias起到一个替代的作用</p>
<h1 id="开始配置nginx反向代理"><a href="#开始配置nginx反向代理" class="headerlink" title="开始配置nginx反向代理"></a>开始配置nginx反向代理</h1><p>将静态资源部署到了nginx服务器之后，我们还要做以下操作配置反向代理以完成请求的路由：</p>
<ul>
<li>设置upstream server</li>
<li>设置动态请求location为proxy pass路径。</li>
</ul>
<p>继续修改nginx.conf（这部分非常关键）：</p>
<h2 id="配置upstream："><a href="#配置upstream：" class="headerlink" title="配置upstream："></a>配置upstream：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">#gzip  on;</span></span><br><span class="line">   upstream seckill_server&#123;</span><br><span class="line">server 应用程序服务器1的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">server 应用程序服务器2的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上面代码为例，seckill_server是这个upstream的别名，下面要用到，ip和端口号指明了应用程序服务器的tomcat的路由地址，weight指明了nginx反向代理服务器配置的轮询是一比一的，也就是一半的请求轮询的路由到应用程序服务器1，一半到应用程序服务器2。（如果应用程序服务器在本机的话，要注意nginx和tomcat的端口号不能冲突，比如本机的tomcat端口号是8080，那么直接server localhost:8080;即可）</p>
<h2 id="配置动态资源的location"><a href="#配置动态资源的location" class="headerlink" title="配置动态资源的location"></a>配置动态资源的location</h2><p>在上一次配置的静态资源的location的下面新增一个配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_pass http://seckill_server; <span class="comment"># 刚刚配置好的别名</span></span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>:<span class="variable">$proxy_port</span>;    </span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;<span class="comment"># 真正的地址是远程的</span></span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment"># nginx作为代理服务器转发请求</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>配置的意思就是如果请求路径不包括resources，那么所有请求都会发送到seckill_server<br>之后sbin/nginx -s reload重启nginx，可以t进入logs目录tail -f error.log查看是否报错。</p>
<p>==2020.2.23更新这里留下的坑==<br>nginx配置upstream的时候名字<strong>不能包含 _ 下划线</strong>！这里我配置的<strong>seckill_server</strong>就完美的踩到了这个坑…这里就不修改了，如果配置的话要注意一下，tomcat8及以上都会有这个问题。</p>
<h1 id="分布式扩展之后的压测"><a href="#分布式扩展之后的压测" class="headerlink" title="分布式扩展之后的压测"></a>分布式扩展之后的压测</h1><p>先将服务器的带宽扩展以减少带宽造成的网络延迟误差。<br>先压测之前的单机服务器，开启1000个线程循环30次，5秒之内启动。<br>结果：<br>average：460ms左右<br>tps：1500左右<br>top -H-&gt;%Cpu(s)：最高达到了80us<br>load average:1.3<br>可以发现单机服务器的负载达到了在这个并发环境下近乎达到了极限。</p>
<p>压测分布式扩展之后的服务器：<br>压测nginx代理服务器的代理地址，并观察数据库服务器的top -H：<br>结果：<br>average：450ms左右<br>tps：==1750==左右<br>top -H-&gt;%Cpu(s)：==2us==<br>load average:0.5<br>可以发现分布式扩展之后数据库服务器的压力明显减小。可以说解决了单机容量的瓶颈问题。</p>
<h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><h2 id="配置nginx和应用服务器长连接"><a href="#配置nginx和应用服务器长连接" class="headerlink" title="配置nginx和应用服务器长连接"></a>配置nginx和应用服务器长连接</h2><p>我们的数据库服务器是通过druid连接池实现连接的，也就是数据库服务器默认是长连接的方式，但是nginx默认是和后端服务器默认是短连接的方式，有建立连接和释放连接的过程，虽然局域网内的服务器短连接耗时很少，但是还是需要优化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">#gzip  on;</span></span><br><span class="line">   upstream seckill_server&#123;</span><br><span class="line">server 应用程序服务器1的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">server 应用程序服务器2的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">keepalive 30;<span class="comment"># 开启keepalive模式，设置keepalive为30秒</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>修改http协议版本以支持keepalive：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">     proxy_pass http://seckill_server;</span><br><span class="line">     <span class="comment">#proxy_set_header Host $http_host:$proxy_port;      </span></span><br><span class="line">     proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">     proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">     proxy_http_version 1.1;</span><br><span class="line">     proxy_set_header Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次压测结果：<br>average：==350ms==左右<br>tps：1750左右（变化不大）<br>top -H-&gt;%Cpu(s)：2us     （变化不大）<br>load average:0.5（变化不大）</p>
<p>可以看出，配置了nginx和后端服务器的长连接之后，平均的请求时长降低了100ms，减少了网络不断建立和释放连接的耗时。</p>
<h1 id="留下的坑"><a href="#留下的坑" class="headerlink" title="留下的坑"></a>留下的坑</h1><p>没有配置分布式的session，因为我的项目的用户登录的信息存储在tomcat的session内，如果nginx通过反向代理路由到了一台没有session的服务区上，那么用户将无法完成需要登录(get session)的操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-4/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记三：jemeter工具对项目接口进行并发压测，初步优化。</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:01:00 / 修改时间：17:03:37" itemprop="dateCreated datePublished" datetime="2020-08-16T17:01:00+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="下载并启动jemeter"><a href="#下载并启动jemeter" class="headerlink" title="下载并启动jemeter"></a>下载并启动jemeter</h1><p>下载好jemeter5并解压之后，可以先打开jemeter目录下的bin\jmeter.properties文件设置语言：在#language=en下面新加一行添加：<strong>language=zh_CN</strong> 设置显示中文。然后直接运行jemeter.bat可以直接在windows端打开压测工具。</p>
<h1 id="jemeter压测配置"><a href="#jemeter压测配置" class="headerlink" title="jemeter压测配置"></a>jemeter压测配置</h1><p>jemeter压测主要需要以下配置：</p>
<ul>
<li>线程组：启动多个并发的线程发送接口请求，用来测试服务端压力，可以配置线程数，循环次数等等。</li>
<li>Http请求：线程组发送http请求，需要指定服务器名称或ip，端口号和压测路径。并且打开keepAlive来忽略因为长连接因素造成的误差。（tips：服务器名称可以通过driver/etc/hosts文件来指定，指定的格式为 <strong>云服务器ip地址  服务器名称</strong>）这样在访问的时候就可以直接输入服务器名称，而不用去记ip。</li>
<li>查看结果树：http请求发送之后，查看http返回的结果。</li>
<li>聚合报告：记录了线程组进行压测的结果的各项指标。包括tps和qps。</li>
</ul>
<h1 id="开始压测"><a href="#开始压测" class="headerlink" title="开始压测"></a>开始压测</h1><p>jemeter内先保存压测的信息，然后点击绿色运行按钮进行压测。然后可以查看结果树和聚合报告：<br>聚合报告内各个标签意义：</p>
<ul>
<li>average：平均响应时间</li>
<li>median：中位数的响应时间</li>
<li>90% line：有百分之90的请求是在这个结果的时间之内返回的，<strong>95% line</strong>， 99% line类似。</li>
<li>min：最短的返回时间</li>
<li>max：最长的返回时间</li>
<li><strong>throughput(tps)：每秒处理事务数，每秒收发包的数量:比如在10秒内成功处理500个并发请求，那么tps就是50。</strong></li>
</ul>
<p>聚合报告中：<strong>比较重要的是95%线和tps。</strong></p>
<p>准备压测：<br>1.ps -ef | grep java 查看java的进程编号，我这里是21079.</p>
<p>2.使用pstree 21079，查看有多少个线程数量</p>
<p>3.top -H 查看服务器的各项实时指标：<br>%cpus ： us为用户占用的， sy为系统占用的，一般观察us<br>load average：代表的收发的压力</p>
<p>4.打开jemeter，设置线程数，这里我设置的线程数为100个，每个线程循环请求10次，共1000次请求，100个线程在10秒内启动。</p>
<p>5.结果，us最高达到了38.8%，没有出错的线程，还不够，再加！<br>设置线程数500个。一边运行一边查看聚合报告，这次qps最高能达到250多。查看top -H发现mysql的cpu占用非常高。因为我测试的接口压力基本都来自数据库。还是不太够，可以直接加多一些，看看出错的原因在哪里。</p>
<p>6.这次我设置线程数为5000，循环100次。这次顶不住了。。。<br>查看 pstree -p 21079 | wc -l  ——&gt;59<br>最高才能走59个并发。所以肯定是有问题的，下面是优化。</p>
<h1 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h1><p>打开项目的springboot内嵌的tomcat的配置文件。<br>查看可能与并发多线程相关的参数：</p>
<p><strong>server.tomcat.accept-count : 默认是100。这个参数是当tomcat的线程被全部占满之后最大的等待队列的大小。即当等待队列达到100个的时候，再进来的请求线程会被拒绝掉。<br>server.tomcat.min-spare-threads ：默认是10。这个是tomcat应对突发的流量入口的时候的默认启动的线程数，可以理解为最小线程数。<br>server.tomcat.max-connections： 默认10000，可接受的最大连接数。<br>server.tomcat.max-threads：默认200。tomcat最大支持的工作线程数。</strong></p>
<p>这样的配置下：连接超过10000之后会出现拒绝连接的情况。请求的线程数超过200+100（等待队列+最大线程数）之后拒绝处理（刚才启动了5000个线程，大量的线程会失败）。</p>
<p>所以我们<strong>第一步的优化就是修改tomcat的并发相关的配置</strong>。不做这个配置任何其他优化都收效甚微。</p>
<p>打开挂载的springboot配置文件application.properties<br>修改上面四个当中的三个配置：<br><strong>server.tomcat.accept-count=800<br>server.tomcat.max-threads=500<br>server.tomcat.min-spare-threads=100</strong></p>
<p><strong>主要将最小线程数和最大线程数调高，并把等待队列大小扩容。<br>但是：<br>1.最大线程数不能无限大，太大的话会花费巨大的时间在cpu调度，一般4核8g的服务器会设置为1000以下，这里我是4g的就设置为500。<br>2.等待队列长度也不能过大，等待队列相当于线程的缓冲池，太大会很耗内存，出入队操作也耗费cpu</strong></p>
<p>设置好之后，重启项目 ./deploy.sh &amp;<br>将并发数调到一个合理的范围：大概200-500之间，循环次数50次。<br>发现延时300ms左右，tps200左右。无错误。</p>
<p>还有比较重要的keepalive方面的参数，springboot并没有对外开放，需要自己写WebServerFactoryCustomize &lt;ConfigurableWebServerFactory&gt;<br>的实现类来配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当spring容器内没有TomcatEmbeddedServletContainerFactory这个bean的时候，会把bean加载进来。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供的接口定制化我们的tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">//定制化keepAliveTimeOut,30秒，30秒内没有请求，服务端才会断开keepalive连接</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//当客户端发送超过10000个请求，则自动断开keepalive连接</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，tomcat的参数优化基本完成，tps仍然不高，后续优化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-3/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记二：springboot项目打包部署到服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:00:06 / 修改时间：17:03:39" itemprop="dateCreated datePublished" datetime="2020-08-16T17:00:06+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="maven打包："><a href="#maven打包：" class="headerlink" title="maven打包："></a>maven打包：</h1><p>进入项目根目录：<br>踩坑1：<br><strong>mvn clean package</strong>，运行target中的jar包<br>java -jar seckill_boot-1.0-SNAPSHOT.jar 报错：<br>jar包中没有主清单属性。<br>原因是这种方式打包的jar没有入口main，也没有各种依赖jar包。<br>需要在pom.xml中导入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">     &lt;configuration&gt;</span><br><span class="line">       &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">       &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">     &lt;/configuration&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br><span class="line">   &lt;plugin&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>踩坑2：<br>导入了依赖，发现打包之后运行仍然找不到主清单属性，原因在于：<br><strong>不能将上面的依赖直接写在其他plugin标签后面！<br>要将上面的依赖另写一个&lt;plugins&gt;&lt;/plugins&gt;大标签内。</strong><br>重新mvn clean package即可。</p>
<h1 id="上传jar包到服务器："><a href="#上传jar包到服务器：" class="headerlink" title="上传jar包到服务器："></a>上传jar包到服务器：</h1><p>1.同样使用xftp上传jar包到tmp目录<br>2.在//var文件夹下mkdir新建 www 文件夹<br>3.新建seckill文件夹<br>4.将jar包移动到seckill文件夹下并重命名为seckill.jar<br><strong>mv //tmp/seckill_boot-1.0-SNAPSHOT.jar ./seckill.jar</strong><br>5.chmod -R 777 *赋予seckill.jar权限，然后java -jar启动<br>6.将阿里云服务器处的80/9999端口打开，开放给0.0.0.0/0<br>7.输入服务器 ip:端口号 确认访问是否成功。</p>
<h1 id="编写外挂配置文件启动"><a href="#编写外挂配置文件启动" class="headerlink" title="编写外挂配置文件启动"></a>编写外挂配置文件启动</h1><p>如果我们要修改项目配置文件的话，那么我们每次都要从本地修改配置文件，打包上传重新部署，这样效率很低。<br>由于jar包内的配置每次都要修改，我们可以配置一个脚本使其覆盖掉jar包内的配置文件的某些属性，达到只改一次就能起效果的状态。</p>
<p>如何使用外挂配置文件的方式启动呢？<br>1.jar包的同级目录下创建application.properties。编辑需要覆盖的属性，这里以server.port=80端口为例测试。<br>2.重新以外挂配置文件启动项目：命令如下：<br><strong>java -jar seckill.jar –spring.config.addition-location=/var/www/seckill/application.properties</strong></p>
<h1 id="编写deploy脚本启动"><a href="#编写deploy脚本启动" class="headerlink" title="编写deploy脚本启动"></a>编写deploy脚本启动</h1><p>在seckill下编写deploy.sh文件:<br><strong>nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar seckill.jar –spring.config.addition-location=/var/www/seckill/applic<br>ation.properties</strong></p>
<p>参数解释：<br>nohup：目的是使java程序不会被中止。<br>-Xms400m -Xmx400m：jvm最小最大都为400m，防止内存不稳定。<br>-XX:NewSize=200m -XX:MaxNewSize=200m： 新生代的最小大小和最大大小，均为200m。</p>
<p>使用 <strong>./deploy.sh &amp;</strong> 命令执行脚本，这个时候终端是看不到输出的。<br>观察输出的方法：使用 <strong>tail -200f nohup.out</strong>命令观察控制台的输出。<br>进入之后就可以实时观察项目运行效果。<br>此时即使ctrl+c退出，也不会影响java程序的运行。</p>
<p>至此为止，完成了使用脚本将项目启动并且不随意退出的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-2/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记一：云服务器安装并部署jdk, mysql</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 16:55:55 / 修改时间：17:01:45" itemprop="dateCreated datePublished" datetime="2020-08-16T16:55:55+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>作为小白一步一步傻瓜式搭建自己的服务器，慢慢来，不着急…….</p>
<h1 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h1><p>首先购买阿里云ECS服务器。根据需求购买，最近因为疫情阿里云还有学生活动，学生党学习课程答题可以免费领，这里我购买的是CentOS的系统。</p>
<h1 id="配置服务器"><a href="#配置服务器" class="headerlink" title="配置服务器"></a>配置服务器</h1><p>1.购买服务器之后，会自动创建实例，如果没有的话看看左上角的区域有没有选错。<br>2.系统创建好实例之后，最好重新设置实例密码和远程连接密码。<br>3.重设密码之后，在网络与安全-安全组-配置规则处添加安全组规则，将自己的ip添加到授权对象中。<br>端口范围：若通过Linux系统连接，则设置为22/22，若通过windows连接，则设置为3389/3389，其他默认即可。</p>
<p><strong>以上所有工作做完，重启服务器！</strong></p>
<p>重启服务器之后，先在网页端测试系统，进入实例列表-远程连接-VNC方式连接，先输入远程连接密码，然后使用root进入系统，输入实例密码即可，这里貌似有个坑，密码中有*号的特殊符号的时候，进入系统好像默认是不开启小键盘的，所以要开启一下小键盘或者用shitf+8直接输，因为密码输入的时候没有光标的移动，所以这里踩坑了。</p>
<h1 id="windows连接服务器及文件的交互"><a href="#windows连接服务器及文件的交互" class="headerlink" title="windows连接服务器及文件的交互"></a>windows连接服务器及文件的交互</h1><p>下载Xshell和Xftp 6，Xshell用来操作系统，Xftp 6用来文件交互。<br>2.两个软件下载好之后，都要新建连接，这里要复制实例的<strong>公有ip</strong>，输入用户名和实例密码之后即可以连接。</p>
<h1 id="服务器安装JDK环境"><a href="#服务器安装JDK环境" class="headerlink" title="服务器安装JDK环境"></a>服务器安装JDK环境</h1><p>1.去Orcale官网下载需要的jdk版本的rpm 安装包。</p>
<p>2.使用Xftp将下载好的rpm安装包移动到服务器中，可以选择移动到tmp文件夹下。</p>
<p>3.在服务器端使用Xshell中： <strong>cd //tmp/</strong> 进入安装包所在的目录， ls查看目录下文件。这里我是红色的 jdk-8u65-linux-x64.rpm</p>
<p>4.因为rpm是自执行文件，所以文件默认是红色的状态，所以要赋予这个文件自执行的权限 ：<br> <strong>chmod 777 jdk-8u65-linux-x64.rpm</strong></p>
<p>5.再次查看tmp下文件ls， 发现原来红色的 jdk-8u65-linux-x64.rpm变为了绿色。此时就可以安装jdk了，使用下面的语句进行安装。<br><strong>rpm -ivh jdk-8u65-linux-x64.rpm</strong></p>
<p>6.安装完成之后，<strong>cd //usr/java</strong>并ls查看是否成功安装。<br>这里显示：<strong>default  jdk1.8.0_65  latest</strong>表示安装成功。</p>
<p>7.使用java -version验证安装即可。</p>
<h1 id="配置jdk的环境变量："><a href="#配置jdk的环境变量：" class="headerlink" title="配置jdk的环境变量："></a>配置jdk的环境变量：</h1><p>1.cd ~<br>2.vim ~/.bash_profile 编辑环境变量文件。<br>3.编辑环境变量: <strong>按i进入插入模式</strong></p>
<p># User specific environment and startup programs</p>
<p><strong>PATH=$PATH:$HOME/bin<br>JAVA_HOME=usr//java/jdk1.8.0_65<br>PATH=$PATH:$JAVA_HOME/bin</strong></p>
<p>export PATH</p>
<p>然后 esc 之后输入 <strong>:wq</strong> 退出即可。<br>配置好java_home的路径，然后将系统的path后面拼接上java_home的bin路径。</p>
<p>4.修改好bash_profile文件之后，必须刷新一下才能生效，进入根目录：<br><strong>source ~/.bash_profile</strong><br>然后再次查看<strong>java -version</strong>，生效，配置环境变量成功。</p>
<h1 id="服务器安装mysql环境"><a href="#服务器安装mysql环境" class="headerlink" title="服务器安装mysql环境"></a>服务器安装mysql环境</h1><p>1.使用 *<em>yum install mysql**</em> 命令安装mysql所有的依赖。遇到提示确认输入y即可。最后会显示Complete!安装成功。</p>
<p>2.<strong>yum install mariadb-server</strong>安装CentOS必须的数据库服务</p>
<p>3.<strong>systemctl start mariadb.service</strong>启动mariadb对应mysql的服务器。</p>
<p>4.<strong>ps -ef | grep mysql</strong>查看mysql是否被启动起来。</p>
<p>5.查看mysql启动的端口号，一般默认为3306.<br><strong>netstat -anp | grep 3306</strong><br>显示tcp        0      0 0.0.0.0:<strong>3306</strong>    ……</p>
<p>6.此时mysql还没设置密码，可以<strong>mysqladmin -u root password 要设置的密码</strong>  来设置mysql的root用户的密码。</p>
<p>7.下面就是mysql的内部的命令了，用mysql -uroot -p密码 登录mysql，下面可以进行数据库的各种操作，不再赘述。</p>
<h1 id="将本机的mysql数据库部署到服务器中"><a href="#将本机的mysql数据库部署到服务器中" class="headerlink" title="将本机的mysql数据库部署到服务器中"></a>将本机的mysql数据库部署到服务器中</h1><p>1.使用mysqldump备份数据库<br>windows下命令：<br><strong>C:\WINDOWS\system32&gt;mysqldump -uroot -p密码 –databases 数据库名 &gt; c:\Download\自己设置的名字.sql</strong></p>
<p>在c:\Download\下会生成一个对应的sql文件，将这个文件上传到服务器的tmp文件夹中</p>
<p>2.服务器端由sql文件生成数据库<br>mysql -uroot -p密码 &lt; //tmp/刚才设置的名字.sql<br>生成完毕，可以查看数据库是否正确。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-1/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记零：基础项目构建流程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 16:54:43 / 修改时间：16:56:39" itemprop="dateCreated datePublished" datetime="2020-08-16T16:54:43+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用springboot2，mybaits3开发的前后端分离基础商城项目"><a href="#应用springboot2，mybaits3开发的前后端分离基础商城项目" class="headerlink" title="应用springboot2，mybaits3开发的前后端分离基础商城项目"></a>应用springboot2，mybaits3开发的前后端分离基础商城项目</h1><ul>
<li><p>tips：项目我<strong>已经部署到了云端服务器，欢迎给本菜鸡提供宝贵意见~</strong></p>
</li>
<li><p><strong>注册入口(项目已下线)：</strong><br><a target="_blank" rel="noopener" href="http://47.115.19.41/resources/getotp.html">点击直接进入注册</a>：<a target="_blank" rel="noopener" href="http://47.115.19.41/resources/getotp.html">http://47.115.19.41/resources/getotp.html</a></p>
</li>
<li><p><strong>本篇README所有内容仅包括基础部分的构建，项目优化的历程放在了我的博客内，不会再到README中更新。</strong></p>
</li>
</ul>
<ul>
<li>项目使用项目根据业务的需要分为用户模块，商品模块，交易模块，以及秒杀模块，如要使用本项目，<strong>需要的数据库表可以根据mapper文件里面的字段来手动建立。</strong>    </li>
</ul>
<h1 id="项目分层"><a href="#项目分层" class="headerlink" title="项目分层"></a>项目分层</h1><h2 id="1-前端UI"><a href="#1-前端UI" class="headerlink" title="1.前端UI"></a>1.前端UI</h2><h2 id="2-接入层controller（对应view-object，即vo）前端返回的是定义好的通用返回对象，若系统正常则返回vo，有异常则返回异常信息和异常状态码。"><a href="#2-接入层controller（对应view-object，即vo）前端返回的是定义好的通用返回对象，若系统正常则返回vo，有异常则返回异常信息和异常状态码。" class="headerlink" title="2.接入层controller（对应view object，即vo）前端返回的是定义好的通用返回对象，若系统正常则返回vo，有异常则返回异常信息和异常状态码。"></a>2.接入层controller（对应view object，即vo）前端返回的是定义好的通用返回对象，若系统正常则返回vo，有异常则返回异常信息和异常状态码。</h2><h2 id="3-业务层service（这里的业务层对象根据阿里巴巴的规范命名为了business-object，即XxBO）包括用户service，商品service，交易下单service，以及秒杀service。"><a href="#3-业务层service（这里的业务层对象根据阿里巴巴的规范命名为了business-object，即XxBO）包括用户service，商品service，交易下单service，以及秒杀service。" class="headerlink" title="3.业务层service（这里的业务层对象根据阿里巴巴的规范命名为了business object，即XxBO）包括用户service，商品service，交易下单service，以及秒杀service。"></a>3.业务层service（这里的业务层对象根据阿里巴巴的规范命名为了business object，即XxBO）包括用户service，商品service，交易下单service，以及秒杀service。</h2><h2 id="4-数据层dao（对应data-object，即do，每一个属性和数据库表一一对应，并且使用mybatis逆向插件自动生成）使用事务保证了数据的一致性。"><a href="#4-数据层dao（对应data-object，即do，每一个属性和数据库表一一对应，并且使用mybatis逆向插件自动生成）使用事务保证了数据的一致性。" class="headerlink" title="4.数据层dao（对应data object，即do，每一个属性和数据库表一一对应，并且使用mybatis逆向插件自动生成）使用事务保证了数据的一致性。"></a>4.数据层dao（对应data object，即do，每一个属性和数据库表一一对应，并且使用mybatis逆向插件自动生成）使用事务保证了数据的一致性。</h2><h1 id="以下是按顺序记录的基本开发流程"><a href="#以下是按顺序记录的基本开发流程" class="headerlink" title="以下是按顺序记录的基本开发流程"></a>以下是按顺序记录的基本开发流程</h1><h1 id="一-技术选型"><a href="#一-技术选型" class="headerlink" title="一.技术选型"></a>一.技术选型</h1><p>springboot2,mysql,druid连接池,mybatis整合springboot依赖.lombok插件<br><strong>以下是mybatis逆向工程插件配置</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis逆向生成工程插件引入 ：START--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--这里core依赖会标红，先放到顶部dependencies标签内下载好再放过来即可--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>mybatis generator<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">goal</span>&gt;</span>generate<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--允许移动生成的文件--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--允许自动覆盖的文件，第二次生成的时候记得设为false--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">            src/main/resources/mybatis-generator.xml</span><br><span class="line">          <span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mybatis逆向工程插件引入 ：END--&gt;</span>  </span><br></pre></td></tr></table></figure>



<h1 id="二-创建数据库及用户信息表，用户密码表，并根据逆向工程插件的配置放置配置文件"><a href="#二-创建数据库及用户信息表，用户密码表，并根据逆向工程插件的配置放置配置文件" class="headerlink" title="二.创建数据库及用户信息表，用户密码表，并根据逆向工程插件的配置放置配置文件"></a>二.创建数据库及用户信息表，用户密码表，并根据逆向工程插件的配置放置配置文件</h1><p>路径：src/main/resources/下创建mybatis-generator.xml,编写方式如下：    </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span>     </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库链接地址账号密码--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/seckillboot?serverTimezone=GMT%2B8&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成DataObject类存放位置,即将user_info和user_password在dataobject下分别建立两个java生成文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.seckill.dos&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成映射文件存放位置,在resources下的mapping下生成映射文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;mapping&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;src/main/resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成Dao类存放位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.seckill.dao&quot;</span>  <span class="attr">targetProject</span>=<span class="string">&quot;src/main/java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--生成对应表及类名--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  enableCountByExample=&quot;false&quot;</span></span><br><span class="line"><span class="comment">               enableUpdateByExample=&quot;false&quot;</span></span><br><span class="line"><span class="comment">               enableDeleteByExample=&quot;false&quot;</span></span><br><span class="line"><span class="comment">               enableSelectByExample=&quot;false&quot;</span></span><br><span class="line"><span class="comment">               selectByExampleQueryId=&quot;false&quot;</span></span><br><span class="line"><span class="comment">               这些属性是为了使得只生成简单查询的对应文件，去掉复杂查询的生成文件，因为一般开发中不太用的到,在table标签里面设置这些</span></span><br><span class="line"><span class="comment">               属性之后，就可以吧xxxDOExample删除掉</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user_info&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;UserDO&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;user_password&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;UserPasswordDO&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableCountByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableUpdateByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableDeleteByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">enableSelectByExample</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">selectByExampleQueryId</span>=<span class="string">&quot;false&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span>    </span><br></pre></td></tr></table></figure>




<h1 id="三-项目配置文件中指定数据源及实现类"><a href="#三-项目配置文件中指定数据源及实现类" class="headerlink" title="三.项目配置文件中指定数据源及实现类"></a>三.项目配置文件中指定数据源及实现类</h1><p>逆向工程已经在项目中分别创建好了dao接口，dos包下dataobject数据表对应类,以及classpath下的mapping文件夹下的mapper映射文件       </p>
<h2 id="1-在项目启动类上添加如下注解-："><a href="#1-在项目启动类上添加如下注解-：" class="headerlink" title="1.在项目启动类上添加如下注解    ："></a>1.在项目启动类上添加如下注解    ：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;&quot;com.seckill&quot;&#125;)</span> <span class="comment">//自动扫描seckill包下面带注解的类，如@Service，@Controller等等      </span></span><br><span class="line">    <span class="meta">@MapperScan(&quot;com.seckill.dao&quot;)</span> <span class="comment">//设置扫描dao接口的包的位置     </span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;...&#125;      </span><br></pre></td></tr></table></figure>

<h2 id="2-在application-properties中添加以下配置："><a href="#2-在application-properties中添加以下配置：" class="headerlink" title="2.在application.properties中添加以下配置："></a>2.在application.properties中添加以下配置：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 指定mybatis映射文件的位置      </span></span><br><span class="line">mybatis.mapper-locations=classpath:mapping/*.xml     </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为数据源指定一个名称，并且配置数据源连接     </span></span><br><span class="line">spring.datasource.name=seckillboot    </span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/seckillboot?serverTimezone=GMT%2B8    </span><br><span class="line">spring.datasource.username=root    </span><br><span class="line">spring.datasource.password=ssss1111   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置数据源实现类为druid   </span></span><br><span class="line">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource     </span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver    </span><br></pre></td></tr></table></figure>

<p>​    </p>
<h1 id="四-完善项目结构：添加service层和controller层"><a href="#四-完善项目结构：添加service层和controller层" class="headerlink" title="四.完善项目结构：添加service层和controller层"></a>四.完善项目结构：添加service层和controller层</h1><p>先编写controller层代码：<br>添加类注解：<br>    @Controller(“user”)<br>    @RequestMapping(“/user”)<br>    添加方法注解<br>    @RequestMapping(“/get”)<br>    @ResponseBody //返回的是json数据而不是地址  </p>
<p>在controller层中编写的UserController类时可以发现以下问题：  </p>
<p>1.controller方法中要调用Service层（已经@Autowired）的方法获取对象响应给前端页面，但是现在只有数据库表对应的UserDO对象。  </p>
<p>2.我们目前先将service层的getUserById的方法的返回类型定义为UserDO，这个UserDO对象所包含的属性如下：    </p>
<p>​        </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;     </span><br><span class="line"><span class="keyword">private</span> String name;     </span><br><span class="line"><span class="keyword">private</span> Byte gender;      </span><br><span class="line"><span class="keyword">private</span> Integer age;       </span><br><span class="line"><span class="keyword">private</span> String telephone;      </span><br><span class="line"><span class="keyword">private</span> String registerMode;   </span><br><span class="line"><span class="keyword">private</span> String thirdPartyId;     </span><br></pre></td></tr></table></figure>


<p>可以发现属性中并不包含密码，这在我们service中是不允许的，service层必须具有business object对象，所以我们新建一个bos包存放模型对象UserBO，即新包含了用户密码属性的对象UserBo，并在service层创建转换方法，从do转换为bo，这里体现为多封装一个用户密码，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> UserBO <span class="title">convertFromDataObjectToBusinessObject</span><span class="params">(UserDO userDO, UserPasswordDO userPasswordDO)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(userDO == <span class="keyword">null</span>)&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        UserBO userBO = <span class="keyword">new</span> UserBO();  </span><br><span class="line">        BeanUtils.copyProperties(userDO, userBO);  </span><br><span class="line">        <span class="keyword">if</span>(userPasswordDO != <span class="keyword">null</span>)&#123;  </span><br><span class="line">            userBO.setEncrptPassword(userPasswordDO.getEncrptPassword());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> userBO;     </span><br><span class="line">        &#125;         </span><br></pre></td></tr></table></figure>

<p>3.在经过第二步的分析之后，我们可以将编写getUserById返回值调整为UserBo，但在通过userPasswordDOMapper获取UserPasswordDO对象时，我们发现原来的mapper只有从select by primary key的逻辑，所以增加了一个select by user_id字段的方法，根据user_id查询用户。最后通过第二步中的转换方法得到的UserBO返回.         </p>
<p>4.我们回到controller层继续编写代码，我们从service层得到了bo对象，这时候绝对不能直接将bo对象直接响应给前端，一是因为bo对象<strong>携带有用户密码</strong>，非常危险，二是bo对象含有<strong>前端不需要的信息</strong>，不需要回传，所以我们要新建一个视图层vos（viewobject）对象，这个视图层对象只包含前台需要的对象属性：<br>在controller层中写如下的转换方法，将从service层获得的bo对象转换为vo对象，并最终返回，vo对象只含以下基本属性：id,name,gender,age,telephone。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> UserVO <span class="title">convertFromBOToVO</span><span class="params">(UserBO userBO)</span></span>&#123;  </span><br><span class="line">      <span class="keyword">if</span>(userBO == <span class="keyword">null</span>)&#123;     </span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">      &#125;  </span><br><span class="line">      UserVO userVO = <span class="keyword">new</span> UserVO();  </span><br><span class="line">      <span class="keyword">return</span> userVO;                                   </span><br><span class="line">      &#125;                </span><br></pre></td></tr></table></figure>


<p>​<br>最后编写的controller层的getUser方法如下：                                </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/get&quot;)</span>                 </span><br><span class="line">      <span class="meta">@ResponseBody</span> <span class="comment">//返回的是json数据而不是地址                    </span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> UserVO <span class="title">getUser</span><span class="params">(<span class="meta">@RequestParam(name=&quot;id&quot;)</span> Integer id)</span></span>&#123;                     </span><br><span class="line">          <span class="comment">//RequestParam获取页面上用户操作从而传过来的id，然后         </span></span><br><span class="line">          <span class="comment">//调用service服务获取对应id的用户对象并返回给前端回显                        </span></span><br><span class="line">          <span class="comment">//但是如下两行代码将加密后密码也返回给了前端，非常危险                         </span></span><br><span class="line">          <span class="comment">//所以为了这个问题加一了层专门为了视图层而创建的模型对象层viewobject(vio)                   </span></span><br><span class="line">          UserBO userBO = userService.getUserById(id);                   </span><br><span class="line">          <span class="comment">//将返回的类型从userModel转换为了userVO，即将核心领域模型对象转化为可供ui使用的viewobject                    </span></span><br><span class="line">          UserVO userVO = convertFromBOToVO(userBO);                        </span><br><span class="line">          <span class="keyword">return</span> userVO;                      </span><br><span class="line">      &#125;        </span><br></pre></td></tr></table></figure>


<h1 id="五-返回类型进一步优化：异常处理"><a href="#五-返回类型进一步优化：异常处理" class="headerlink" title="五. 返回类型进一步优化：异常处理"></a>五. 返回类型进一步优化：异常处理</h1><p>我们使用把返回的uservo转换为一种CommonReturnType的形式来实现归一化的异常处理，具体方法为：  </p>
<p>1.定义一个CommonReturnType类，其内部有两个属性：string的status状态信息（success或者fail），以及object类型的data，正常返回（status=success）时里面是的前端需要的信息，出现错误（status=fail）时则保存了错误的错误码和错误信息。  </p>
<p>2.CommonReturnType类内部定义两个创建自身对象的重载方法create，如果传参时只有data而不带任何的状态码，那么就是success，并通过方法内部再调用第二个重载方法把对应的result封装返回；如果传参时就带状态码和status，那么就会直接调用第二个重载的方法 ，并且result我们可以设置为错误信息.  </p>
<p>3.这一步我们要实现将status为fail时，对CommonReturnType的data的设置，我们可以将其设置为一个错误码，和对应错误码的错误信息,即errCode和errMsg，要实现这个功能，我们可以先定义一个CommonError接口：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMessage</span><span class="params">()</span></span>;  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> CommonError <span class="title">setErrMsg</span><span class="params">(String errMsg)</span></span>;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure>


<p>4.我们要创建一个枚举类并实现CommonError接口，内部有errCode和errMsg属性，枚举类对象即为错误状态，创建有参构造函数内含两个参数，  即errCode和errMsg，并且在枚举类中实现好接口中的方法将错误码和错误信息的封装，以及错误信息的设置；<br>再创建一个BusinessException类继承Exception并也实现CommonError接口BusinessException和EmBusinessError。都实现了CommonError中定义的方法：<br>这样外部不仅可以new BusinessException 也可以new EmBusinessError ，也都可以有对应的errCode和errMsg并且都实现了setErrMsg的方法，这样BusinessException可以将原来EmBusinessError定义的errMsg覆盖掉  </p>
<ul>
<li>BusinessException内部有两个重载的构造函数：    </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接接收EmBusinessError的传参用于构造业务异常                </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span></span>&#123;           </span><br><span class="line">      <span class="keyword">super</span>();                  </span><br><span class="line">      <span class="keyword">this</span>.commonError = commonError;                         </span><br><span class="line">   &#125;               </span><br><span class="line">   <span class="comment">//接收自定义errMsg的方式构造业务异常           </span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError, String errMsg)</span></span>&#123;             </span><br><span class="line">      <span class="keyword">super</span>();               </span><br><span class="line">      <span class="keyword">this</span>.commonError = commonError;                                           </span><br><span class="line">      <span class="keyword">this</span>.commonError.setErrMsg(errMsg);                    </span><br><span class="line">   &#125;     </span><br></pre></td></tr></table></figure>


<p>5.定义exceptionHandler解决未被controller层吸收的exception异常，我们可以用springboot的异常处理的注解<br>     @ExceptionHandler(Exception.class)//固定写法，写在要处理exception的方法之上<br>     @ResponseStatus(HttpStatus.OK)//将异常置为ok状态，以便于回显异常信息<br>     @ResponseBody //以json形式返回异常信息 返回的是status（fail）以及data（errCode，errMsg）<br>     上述的方法要抽取到BaseController类中，并让UserController继承此类，实现controller层共用代码的抽取     </p>
<h1 id="六-实现用户获取手机验证码功能"><a href="#六-实现用户获取手机验证码功能" class="headerlink" title="六.实现用户获取手机验证码功能"></a>六.实现用户获取手机验证码功能</h1><h2 id="1-usercontroller内创建用户获取otp短信的方法"><a href="#1-usercontroller内创建用户获取otp短信的方法" class="headerlink" title="1.usercontroller内创建用户获取otp短信的方法"></a>1.usercontroller内创建用户获取otp短信的方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//basecontroller内定义public static final String CONTENT_TYPE_FORMED=&quot;application/x-www-form-urlencoded&quot;;  </span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/getotp&quot;, consumes = &#123;CONTENT_TYPE_FORMED&#125;)</span>  </span><br><span class="line">    <span class="meta">@ResponseBody</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getOtp</span><span class="params">(<span class="meta">@RequestParam(name = &quot;telephone&quot;)</span> String telephone)</span></span>&#123;  </span><br><span class="line">        <span class="comment">//需要按照一定的规则生成otp验证码  </span></span><br><span class="line">        Random random = <span class="keyword">new</span> Random();    </span><br><span class="line">        <span class="comment">//[0, 900000)随机数  </span></span><br><span class="line">        <span class="keyword">int</span> randomInt = random.nextInt(<span class="number">900000</span>);  </span><br><span class="line">        randomInt += <span class="number">100000</span>; <span class="comment">//[100000, 1000000)  </span></span><br><span class="line">        String otpCode = String.valueOf(randomInt);  </span><br><span class="line"></span><br><span class="line">        <span class="comment">//将otp验证码同对应用户的手机号关联,使用httpsession的方式绑定用户的手机号和otpCode  </span></span><br><span class="line">        httpServletRequest.getSession().setAttribute(telephone, otpCode);<span class="comment">//用户的otpCode被用户手机号关联  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟将otp验证码通过短信通道发送给用户，这里省略这个方式,并替换为打印到控制台的方式  </span></span><br><span class="line">        System.out.println(<span class="string">&quot;telephone = &quot;</span> + telephone + <span class="string">&quot; &amp; otpCode = &quot;</span> + otpCode);<span class="comment">//telephone = 13833333333 &amp; otpCode = 47733  </span></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(<span class="keyword">null</span>);  </span><br><span class="line">     &#125;          </span><br></pre></td></tr></table></figure>

<h2 id="2-使用前后端分离的方式，可以不在项目内部文件夹中编写html，写getotp-html，代码见getotp-html，重点是ajax异步请求部分"><a href="#2-使用前后端分离的方式，可以不在项目内部文件夹中编写html，写getotp-html，代码见getotp-html，重点是ajax异步请求部分" class="headerlink" title="2.使用前后端分离的方式，可以不在项目内部文件夹中编写html，写getotp.html，代码见getotp.html，重点是ajax异步请求部分"></a>2.使用前后端分离的方式，可以不在项目内部文件夹中编写html，写getotp.html，代码见getotp.html，重点是ajax异步请求部分</h2><p>tips：要实现前后端分离还需要允许跨域请求，需要在UserController上面添加@CrossOrigin的springboot注解，允许前端ajax请求跨域。<br>    3.使用metronic框架美化getotp.html，引入  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;static/assets/global/plugins/bootstrap/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;static/assets/global/css/components.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;static/assets/admin/pages/css/login.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure>
<p>并在相应标签内加入class属性即可给页面元素添加样式  </p>
<h1 id="七-实现用户注册功能"><a href="#七-实现用户注册功能" class="headerlink" title="七.实现用户注册功能"></a>七.实现用户注册功能</h1><h2 id="1-在controller层内写用户注册方法"><a href="#1-在controller层内写用户注册方法" class="headerlink" title="1.在controller层内写用户注册方法"></a>1.在controller层内写用户注册方法</h2><p>首先从session内获取验证码和用户接收到的验证码是否相同，合法后进入下一步<br>将用户的传参都封装到一个bo对象中，特别注意密码要md5加密，，将对象传到service层的注册方法的参数中，下一步是在service层中编写注册方法  </p>
<h2 id="2-在service层编写注册方法"><a href="#2-在service层编写注册方法" class="headerlink" title="2.在service层编写注册方法"></a>2.在service层编写注册方法</h2><p>先判断传过来的bo是否为空，完成参数校验（见下面的步骤）  </p>
<p>方法外编写bo转换为do的私有方法和passwordbo转换为passworddo的方法，分别调用dao层mapper将这两个对象插入数据库的两个数据表，（使用insertSelective可以使用数据库字段默认值）最后返回。<br>注意：通过在对应mapper的insertSelective标签中设置keyProperty=”id” useGeneratedKeys=”true”，可以将插入时自动生成的自增的id取出，转换时的passworddo就可以获取插入的user的id  </p>
<h2 id="3-编写前端代码"><a href="#3-编写前端代码" class="headerlink" title="3.编写前端代码"></a>3.编写前端代码</h2><p>register.html具体代码见项目中，注意要将所有页面元素（bo级别的属性）全部获取并判空  。并且在controller上面添加<code>@CrossOrigin(allowCredentials = &quot;true&quot; ,allowedHeaders = &quot;*&quot;)</code>的注解属性，前端的ajax请求中添加：<code>xhrFields:&#123;withCredentials:true&#125;，//允许跨域请求</code>  </p>
<p>在数据库将用户电话设置为唯一索引，并<code>catch DuplicateKeyException</code>提示用户不能使用同一手机号重复注册  </p>
<h1 id="八-实现用户登录功能，并优化参数校验规则"><a href="#八-实现用户登录功能，并优化参数校验规则" class="headerlink" title="八.实现用户登录功能，并优化参数校验规则"></a>八.实现用户登录功能，并优化参数校验规则</h1><p>1.在controller层内写用户登录方法<br>2.在service层编写验证登录方法，这里去mapper里面增加一个通过手机号获取用户信息的sql，</p>
<p>通过用户的手机号获取用户do，并通过do中的userid获取用户数据库中密码，和用户传进来的密码是否相同，不相同则抛异常即可<br>   若用户密码正确则将用户登录的凭证放进session内，并返回成功的commonreturntype<br>3.写前端页面，见login.html  </p>
<p>4.优化参数校验，引入hibernate-validator，编写ValidationResult设置其属性为boolean型的：参数是否错误 和map型的errMsg  </p>
<p>编写ValidatorImpl类并实现InitializingBean类以及当中的方法，方法内将将hibernate validator通过工厂化的初始化方式使其实例化，并编写validate方法将错误信息封装到ValidationResult中<br>   在service层中注入ValidatorImpl，在注册方法中使用validate方法校验userbo，在userbo的属性上添加参数校验的注解即可自动校验，若ValidationResult获取的校验结果为false则抛出异常，bo的注解如下  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;用户名不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;没有填写性别&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Byte gender;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;没有填写年龄&quot;)</span></span><br><span class="line">    <span class="meta">@Min(value = 0, message = &quot;年龄必须大于0&quot;)</span></span><br><span class="line">    <span class="meta">@Max(value = 150, message = &quot;年龄必须小于150&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;手机号不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line">    <span class="keyword">private</span> String registerMode;</span><br><span class="line">    <span class="keyword">private</span> String thirdPartyId;</span><br><span class="line">    <span class="comment">//不同于do的属性</span></span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;密码不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String encrptPassword;</span><br></pre></td></tr></table></figure>

<h1 id="九-开始商品（item）模块开发"><a href="#九-开始商品（item）模块开发" class="headerlink" title="九.开始商品（item）模块开发#"></a>九.开始商品（item）模块开发#</h1><h2 id="1-建立商品bo和数据库表"><a href="#1-建立商品bo和数据库表" class="headerlink" title="1.建立商品bo和数据库表"></a>1.建立商品bo和数据库表</h2><p>商品bo的属性包括商品id，名称，价格，库存，描述，销量，商品图片.<br>    建立有关商品的数据库表，商品库存要和商品信息分表，因为库存与交易流水有关，还要注意价格字段若设置为decimal时，只有长度大于20时，逆向工程才会生成big decimal的price<br>    使用mybatis逆向工程生成do，mapper和mapperxml，注意设置pom文件中自动覆盖设置为false，并且提前给所有insert标签加上keyProperty=”id” useGeneratedKeys=”true”才能获取插入时的id  </p>
<h2 id="2-创建商品service接口，并添加：创建商品、获取商品详情、获取商品列表的功能，这里是创建商品"><a href="#2-创建商品service接口，并添加：创建商品、获取商品详情、获取商品列表的功能，这里是创建商品" class="headerlink" title="2.创建商品service接口，并添加：创建商品、获取商品详情、获取商品列表的功能，这里是创建商品"></a>2.创建商品service接口，并添加：创建商品、获取商品详情、获取商品列表的功能，这里是创建商品</h2><p>创建商品的service层：将传过来的商品bo转化为两个do，然后分别插入数据库即可，并且将插入时获取的商品id赋给插入库存表之前的bo，以便库存表插入时携带有itemid。<br>    最后，将插入的两个do再转换为一个插入的bo对象，并且返回它供controller层使用  </p>
<p>创建商品的controller层：编写创建商品方法  ：</p>
<p>这里的创建代码很简单，从前端获取需要的所有属性，封装给一个bo对象，调用controller层的创建商品方法，转换为vo对象（商品的vo用到了bo的全部属性）返回commtype.create（创建出来的带id的vo即可）<br>    编写前端代码，这里出了bug就是因为数据库逆向生成的属性为double price，导致数据库里面插入的价格一直为零，所以要将数据库里面的价格字段长度改为20才可以正常插入价格字段  </p>
<h2 id="3-实现获取商品列表的功能"><a href="#3-实现获取商品列表的功能" class="headerlink" title="3.实现获取商品列表的功能"></a>3.实现获取商品列表的功能</h2><p>在商品的mapper中添加select 全部字段的方法,在service层中编写listItem方法，将查询出来的list<do> 中的所有的do对象转换为bo，并且返回这个list<bo>（这里应用的jdk8的stream api）<br>    编写controller代码，将调用的service中的方法返回的list&lt;bo&gt; 中的所有的bo对象转换为vo，并且createlist&lt;bo&gt;<br>    编写商品列表浏览的前端代码，这里前端代码有些复杂，还需研究.并在商品的列表页的每行商品处添加跳转，跳转到获取对应这个商品的商品详情页。  </p>
<h2 id="4-实现获取商品明细的功能"><a href="#4-实现获取商品明细的功能" class="headerlink" title="4.实现获取商品明细的功能"></a>4.实现获取商品明细的功能</h2><p>service层根据id获取到商品bo，controller层调用这个方法并且转化为vo即可，这里后台代码比较简单，前端代码较复杂.  </p>
<h1 id="十-开始交易模块的开发"><a href="#十-开始交易模块的开发" class="headerlink" title="十.开始交易模块的开发"></a>十.开始交易模块的开发</h1><h2 id="1-建立交易模型，即orderBO入手，思考需要的属性：有以下属性"><a href="#1-建立交易模型，即orderBO入手，思考需要的属性：有以下属性" class="headerlink" title="1.建立交易模型，即orderBO入手，思考需要的属性：有以下属性"></a>1.建立交易模型，即orderBO入手，思考需要的属性：有以下属性</h2><p>id（交易号）、用户id、商品id、购买数量、订单总价。然后建立数据库表order_info，这里的数据库表属性直接对应orderbo即可，建立完数据库表，用逆向工程生成mapper和do对象  </p>
<h2 id="2-用户下单过程"><a href="#2-用户下单过程" class="headerlink" title="2.用户下单过程"></a>2.用户下单过程</h2><p>在service层编写orderService并思考需要的方法：现在有了交易表，就从交易表入手思考，得出需要建立新建交易的方法，参数为用户id、商品id、购买数量。编写实现类，<br>        这里采取落单减库存的操作，在itemservice内创建减库存的方法，在itemstockmapper对中编写decreaseStock的update sql，方法参数为商品id和购买数量，实现减库存，<br>        减完库存我们需要将订单的信息封装到一个orderbo中，注意封装的orderprice为总价需要计算，还有封装的订单id需要由单独的一个方法完成，前八位设置为年月日，最后两位暂且为零 ,其他中间几位一次按step递增，并且因为这个功能要新建一个sequence表，里面记录curretvalue和step，按照step递增并记录订单id的中间几位）到此为止封装完了bo的全部属性，同样将bo转换为do对象，转换完毕加入订单数据表。<br>这里还需要实现增加销量的方法，参数为商品的id和购买数量，并在mapper对中添加update的sql。<br>至此serveice层编写完毕，返回了一个订单模型  </p>
<p>来到controller层，编写创建订单的方法，其中，商品id和商品的购买数量从前台传参即可获得，用户id可以从session中的userbo（之前的登录方法中setattribute有设置过）获得，顺便还可以检查用户是否登录。<br>        接下来就是调用order service的create，并返回CommonReturnType.create(orderBO)即可  </p>
<p>前端代码在商品详情页面编写，添加一个购买按钮，给其绑定单击时间添加ajax请求即可,下单成功之后添加reload可以看到下单后库存减少的方法。<br>        若没有秒杀模块的需求，项目至此基本的功能已经完成  </p>
<h1 id="十一-开始秒杀活动的开发"><a href="#十一-开始秒杀活动的开发" class="headerlink" title="十一.开始秒杀活动的开发"></a>十一.开始秒杀活动的开发</h1><h2 id="1-秒杀模型的创建，同样从bo入手"><a href="#1-秒杀模型的创建，同样从bo入手" class="headerlink" title="1.秒杀模型的创建，同样从bo入手"></a>1.秒杀模型的创建，同样从bo入手</h2><p>创建的business model模型属性有：秒杀模型的id, 秒杀活动名称， 秒杀开始时间， 秒杀结束时间， 秒杀的商品， 秒杀商品价格 ，然后建立数据库表，这里可以直接对应秒杀bo的属性即可<br>    需要注意的是，秒杀数据表的表名不能是【kill】，这里和sql的关键字会冲突，出现了bug。<br>    建立好数据表同样应用逆向工程生成对应的秒杀do和秒杀mapper对，这里可以直接在数据表上添加一个已经设置好的商品秒杀来模拟。   </p>
<h2 id="2-获取商品的秒杀模型"><a href="#2-获取商品的秒杀模型" class="headerlink" title="2.获取商品的秒杀模型"></a>2.获取商品的秒杀模型</h2><p>在新建秒杀service，并且添加：根据商品id获取秒杀模型的方法<br>    在数据库mapper对添加根据商品id获得秒杀模型的sql，同样，将查询出来的do转换为bo，之后根据获取的秒杀开始和结束时间来set这个商品对应秒杀模型的状态，最后返回秒杀的bo     </p>
<h2 id="3-聚合模型"><a href="#3-聚合模型" class="headerlink" title="3.聚合模型"></a>3.聚合模型</h2><p>将秒杀bo聚合为商品bo的属性之一，此时商品模型就成为了聚合模型，在商品的service层插入代码片段进行秒杀模型的聚合，即itemBo.setKillBO  </p>
<h2 id="4-视图层逻辑编写"><a href="#4-视图层逻辑编写" class="headerlink" title="4.视图层逻辑编写"></a>4.视图层逻辑编写</h2><p>在itemVO中添加killStatus属性来定义商品秒杀状态为0：表示没有秒杀活动，为1：表示秒杀活动进未开始，为2：表示秒杀进行中<br>    继续在vo中添加秒杀价格，秒杀活动模型id，秒杀开始时间的属性，这些都是前端页面需要获取的有用信息，再到itemController中的从商品bo转换为vo的方法中添加代码，<br>    根据是否获取到了秒杀模型来给killStatus，秒杀价格，秒杀活动模型id，秒杀开始时间这几个属性赋值，返回重新封装好的vo即可。  </p>
<h2 id="5-前台代码编写"><a href="#5-前台代码编写" class="headerlink" title="5.前台代码编写"></a>5.前台代码编写</h2><p>根据业务需要修改前台需要显示的值即可，这里注意时间格式的转化，以及倒计时模块的写法   </p>
<h2 id="6-修改order订单相关代码契合秒杀业务"><a href="#6-修改order订单相关代码契合秒杀业务" class="headerlink" title="6.修改order订单相关代码契合秒杀业务"></a>6.修改order订单相关代码契合秒杀业务</h2><p>在订单的bo中加入秒杀活动的id属性，意义为若秒杀id非空，则表示以秒杀商品方式下单，且对应的商品价格，订单总价属性也要随着秒杀业务的变化为变化<br>    在订单数据表中添加对应的秒杀活动id字段，在do中添加相应的属性，mapper对也添加秒杀活动id的字段，这里手动添加不知道为什么总出错，自动生成就不报错  </p>
<p>在service层代码的创建订单的方法的入参中添加秒杀活动id的参数，再方法内添加代码校验活动信息，在订单入库处的代码增加封装秒杀活动id的代码，并且根据秒杀活动的状态获取不同的商品价格  </p>
<p>在controller层创建订单的方法上添加新的前端传过来的入参：killId，并且将required设置为false，即如果前端没有传值就是没有秒杀进行<br>前端则实现倒计时，时间到了之后将下单按钮释放，点击按钮才可以发送killId不为null。   </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Stephen Jia</p>
  <div class="site-description" itemprop="description">Try Everything......</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Jia</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
