<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"jiazx.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Try Everything......">
<meta property="og:type" content="website">
<meta property="og:title" content="J Blog">
<meta property="og:url" content="http://jiazx.top/page/4/index.html">
<meta property="og:site_name" content="J Blog">
<meta property="og:description" content="Try Everything......">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Stephen Jia">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://jiazx.top/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>J Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">J Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-2/" class="post-title-link" itemprop="url">JUC学习笔记二：线程间的通信；同步方法锁的理解；juc集合类简介</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:08:59 / 修改时间：17:17:06" itemprop="dateCreated datePublished" datetime="2020-08-16T17:08:59+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、线程间的通信之while防止虚假唤醒"><a href="#一、线程间的通信之while防止虚假唤醒" class="headerlink" title="一、线程间的通信之while防止虚假唤醒"></a>一、线程间的通信之while防止虚假唤醒</h1><p>  在对多个线程操作共享数据的逻辑进行同步时，要避免使用if判断的方式使某线程进入waiting状态，要改为使用while。原因是while可以防止虚假唤醒：    </p>
<p>  用if使线程进入waiting可能会使判断过的正在等待被唤醒的线程直接进入，不管符不符合if的条件；而while则会重新判断当前正在waiting的线程是否符合while()内的条件，保证多个线程之间不会有虚假唤醒的情况。  </p>
<p>举例：四个线程操作一个数字number，number只能为1或者0，两个线程负责将number加1，另外两个线程负责将number减1。四个线程都各自执行十次，最后执行时要保证number的加1和减1循环交替。（注意，这里使用四个线程作为例子是因为：如果只有两个线程，一个线程唤醒的另一个线程是唯一的。但如果设置为四个线程，一个线程唤醒的其他线程不唯一，就会产生随机性）,这里使用Condition对象的await()和signalAll()方法来操作线程的等待和唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获得资源类的对象</span></span><br><span class="line">        AirCondition airCondition = <span class="keyword">new</span> AirCondition();</span><br><span class="line">        <span class="comment">//启动四个线程，两个线程调用加一方法，两个线程调用减一方法，分别执行十次</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    airCondition.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AirCondition</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使number加1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//线程进入waiting</span></span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++;</span><br><span class="line">            <span class="comment">//唤醒其他所有正在waiting的线程</span></span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使number减1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number --;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后的执行结果（应该应该有40行，这里省略）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">1</span></span><br><span class="line">B:<span class="number">0</span></span><br><span class="line">C:<span class="number">1</span></span><br><span class="line">B:<span class="number">0</span></span><br><span class="line">C:<span class="number">1</span></span><br><span class="line">D:<span class="number">0</span></span><br><span class="line"><span class="comment">//......略  </span></span><br></pre></td></tr></table></figure>


<p>但是，如果我将increment和decrement方法中的while全都替换为if<br>即：  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使number加1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//while换成if</span></span><br><span class="line">            <span class="keyword">if</span>(number != <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number ++;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使number减1的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//while换成if</span></span><br><span class="line">            <span class="keyword">if</span>(number == <span class="number">0</span>)&#123;</span><br><span class="line">                condition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number --;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+number);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这时，运行的结果就可能会产生错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:<span class="number">1</span></span><br><span class="line">B:<span class="number">0</span></span><br><span class="line">C:<span class="number">1</span></span><br><span class="line">A:<span class="number">2</span></span><br><span class="line"><span class="comment">//......略</span></span><br></pre></td></tr></table></figure>
<p>可以发现，这里出现了2的情况。原因如下：  </p>
<ol>
<li><p>线程A、C是加1的线程，B、D是减1的线程。  </p>
</li>
<li><p>在第一行，A抢到了锁，操作number加一并释放锁。  </p>
</li>
<li><p>在第二行的竞争中，C其实最先抢到了锁，但是由于此时number还是1，if条件判断不符合，所以C进入了waiting状态。  </p>
</li>
<li><p>在第三步C进入waiting状态之后，剩下三个线程又开始竞争锁，此时，A又拿到锁，但是由于if的判断，仍然不符合，所以A也进入等待状态。 此时A,C都进入waiting状态。再拿到锁的只能是B或者D减1的方法。</p>
</li>
<li><p>这时B拿到了锁，操作number减1。A，C还在waiting状态。</p>
</li>
<li><p>第二行B执行完毕，唤醒其他线程的瞬间：还在waiting状态的A，C瞬间被唤醒。因为if只在线程第一次拿到锁的时候执行单次判断，C，A此时没有被再次进入if判断，先后立即执行了加一的操作，number变为2，出错。</p>
</li>
</ol>
<p>总结：<br>不能在线程的等待判断逻辑处用if，要用while来保证不会有虚假唤醒，即被唤醒的正在waiting的线程一定会在符合while内条件的情况下才执行。</p>
<p>练习：使用一个lock的多个Condition对象来精准操控线程的执行顺序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**线程A打印5次，线程B打印10次，线程C打印15次 --- 循环十遍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PrintData printData = <span class="keyword">new</span> PrintData();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                printData.printTimes(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                printData.printTimes(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                printData.printTimes(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintData</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;<span class="comment">//A : 1, B : 2, C : 3</span></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//使用同一个lock的多个Condition对象来操控多个线程的工作顺序</span></span><br><span class="line">    <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition[] conditions = &#123;c1, c2, c3&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTimes</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> nextN)</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//while防止虚假唤醒</span></span><br><span class="line">            <span class="keyword">while</span>(number != n)&#123;</span><br><span class="line">                conditions[n - <span class="number">1</span>].await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= number * <span class="number">5</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;\t&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">                number = nextN;</span><br><span class="line">                conditions[nextN - <span class="number">1</span>].signal();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二、同步方法锁的理解"><a href="#二、同步方法锁的理解" class="headerlink" title="二、同步方法锁的理解"></a>二、同步方法锁的理解</h1><p>如下代码，分别改写为8种情况，写出Phone内方法的打印顺序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendEmail</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sendMS</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EightLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                phone.sendEmail();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//sleep一下保证默认情况下的先后顺序</span></span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//                phone.sendMS();</span></span><br><span class="line"><span class="comment">//                phone.sayHello();</span></span><br><span class="line">                phone2.sendMS();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1.标准访问，两个方法均为普通同步方法-&gt;           email, ms</li>
<li>2.在发邮件方法中暂停4秒-&gt;仍为email,ms 因为是一把锁</li>
<li>3.新增普通非同步sayHello方法在B中执行。-&gt;hello , email:<br>因为普通方法不会被锁 </li>
<li>4.两部手机phone1在A执行发邮件，phone2在B执行发短信 -&gt;              ms, email: 此时先执行没有被暂停四秒的B线程，因为普通同步方法锁的是自身对象，这里有两个对象，就是两把锁，互不干扰。</li>
<li>5.两个静态同步方法-&gt;     email,ms</li>
<li>6.两个静态同步方法，两个手机 -&gt;email,ms：】调用静态的同步方法，锁的就是整个类】锁的是当前类的Class对象，即使是两个不同类的对象，只要是一个类的就会被锁。所以是同一把锁。（注意，前提是二者都是对象）</li>
<li>7.一个静态同步方法，一个普通同步方法，同一部手机-&gt; ms email:同理，静态同步方法的锁是Class，普通同步方法的锁是自身对象。二者不一致，所以是两把锁，互不干扰。</li>
<li>8.一个静态同步方法，一个普通同步方法，两部手机-&gt;  ms email:显然为两把锁。</li>
</ul>
<h1 id="三、juc中的线程安全的集合类简介"><a href="#三、juc中的线程安全的集合类简介" class="headerlink" title="三、juc中的线程安全的集合类简介"></a>三、juc中的线程安全的集合类简介</h1><p>实验：启动三十个不同的线程将三十个随机字符串添加到一个集合类中<br>这里以ArrayList为例，其实换为set和map也有一样的效果  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//启动三十次三十个不同的线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//添加三十个不同的随机字符串</span></span><br><span class="line">                list.add(UUID.randomUUID().toString().substring(<span class="number">0</span>, <span class="number">8</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的方法，会报<code>java.util.ConcurrentModificationException</code>的并发修改异常。原因是：普通ArrayList不是线程安全的。解决方式：<br>1.使用Vector<br>2.使用Collections工具类的<code>Collections.synchronizedList(new ArrayList&lt;&gt;())</code><br>3.使用 <code>CopyOnWriteArrayList&lt;&gt;()</code>写时复制的list，使用方法：<code>List&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();</code>即可。</p>
<h2 id="CopyOnWriteArrayList："><a href="#CopyOnWriteArrayList：" class="headerlink" title="CopyOnWriteArrayList："></a>CopyOnWriteArrayList：</h2><p>CopyOnWriteArrayList的类声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8673264195747942595L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The lock protecting all mutators */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The array, accessed only via getArray/setArray. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CopyOnWriteArrayList的添加元素的add方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray();</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>写时复制 copyOnWrite 容器即写时复制的容器 ，往容器添加元素的时候,不直接往当前容器object[]添加,而是先将当前容器object[]进行 copy 复制出一个新的object[] newElements 然后向新容器object[] newElements 里面添加元素 添加元素后，再将原容器的引用指向新的容器 setArray(newElements);<br>这样的好处是可以对copyOnWrite容器进行并发的读,而不需要加锁.所以copyOnwrite容器也是一种<strong>读写分离的思想</strong>,读和写不同的容器.</p>
<p>知识补充：HashSet底层是HashMap，不过这个HashMap的value是一个常量Object。<br>同理：HashSet，HashMap也是线程不安全的，他们也分别可以通过juc包下的<code>**CopyOnWriteSet** </code>和 <code>**ConcurrentHashMap** </code>集合类替代来解决集合的并发问题。</p>
<h2 id="ConcurrentHashMap："><a href="#ConcurrentHashMap：" class="headerlink" title="ConcurrentHashMap："></a>ConcurrentHashMap：</h2><p>我们知道HashMap在多线程情况下不仅不安全，而且会产生死锁。</p>
<p>其中一个解决的办法是使用HashTable，但是HashTable这个容器里面绝大部分方法都是使用synchronized关键字来保证线程安全的，这样的同步显得太过“臃肿”，因为synchronized加到方法上会是一个对象锁，把整个HashTable锁住，一把锁锁整个对象，这样一个线程进来操作HashTable的话，其他所有synchronized方法都不能被其他线程执行，效率非常低下。</p>
<p>那么ConcurrentHashMap就是一个很好的保证线程安全，并且相对来说效率较好的容器。</p>
<p>ConcurrentHashMap如何保证线程安全的？<br>在JDK7中，ConcurrentHashMap是将HashMap分为一个一个的Segment，一个Segment包含多个HashEntry然后再给这些Segment加上分段锁。即同一段Segment才需要考虑同步，不是一段的不考虑。并且get操作无需加锁，ConcurrentHashMap的主干是个Segment数组。继承了ReentrantLock，可重入锁（ReentrantLock)。对于一个key进行三次哈希操作才可以确定最终位置，第一次得到key的hash，第二次得到高位的hash值，确定segment，第三次哈希确定具体在哪个entry</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85OTMwNzYzLWQwMjM1MDExOTFkMTgzOTcucG5n?x-oss-process=image/format,png" alt="在这里插入图片描述"><br>JDK8中ConcurrentHashMap的实现使用的是锁分离思想，只是锁住的是一个node(这个node是链表的头结点或者是红黑树的根节点)，而锁住Node之前的操作是基于在volatile和CAS之上无锁并且线程安全的。<br>在插入的过程中（put）若计算出来的位置没有结点占用：通过cas插入即可。如果这个位置上面有元素了，那么synchronized(这个位置链表的头结点)插入到尾部。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/juc-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/juc-1/" class="post-title-link" itemprop="url">JUC学习笔记一：复习多线程操作资源类的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:08:07 / 修改时间：17:08:54" itemprop="dateCreated datePublished" datetime="2020-08-16T17:08:07+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="高内聚，低耦合"><a href="#高内聚，低耦合" class="headerlink" title="高内聚，低耦合"></a>高内聚，低耦合</h1><p>所谓高内聚，低耦合就是每个程序要实现的特定功能要尽量多的在自己的内部完成，对外部提供很少量的接口以便调用。</p>
<h1 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h1><p>并行即多个任务在自己的分配的各自的资源上执行，即多个任务同时跑，互不冲突。<br>并发即多个任务在统一的一个资源内执行，多个任务会抢占同一资源，在cpu中体现为交替执行，并不能同时执行，但是cpu在多个线程中切换的速度会非常快，所以宏观上看似是同时的。<br>最大的区别体现在【同时】上。<br>并行：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83NTU3MzczLTcyOTEyZWE4ZTg5YzQwMDcuanBn?x-oss-process=image/format,png" alt="并行"><br>并发：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy83NTU3MzczLWRhNjRmZmQ2ZDFlZmZhYWMuanBn?x-oss-process=image/format,png" alt="并发"></p>
<h1 id="复习多线程创建的四种方式"><a href="#复习多线程创建的四种方式" class="headerlink" title="复习多线程创建的四种方式"></a>复习多线程创建的四种方式</h1><h2 id="1-创建线程的方式一：继承Thread类的方式"><a href="#1-创建线程的方式一：继承Thread类的方式" class="headerlink" title="1.创建线程的方式一：继承Thread类的方式"></a>1.创建线程的方式一：继承Thread类的方式</h2><p>使用方法：</p>
<ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()<ul>
<li>例子：利用包含main线程在内的三个线程分别遍历10以内所有偶数</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个继承于thread类的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="comment">//2. 重写Thread类的run()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//遍历10以内所有偶数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建Thread类的子类的对象</span></span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4. 通过此对象调用start() 启动当前线程，调用当前线程的run()</span></span><br><span class="line">        <span class="comment">//注意的问题一：我们不能通过直接调用对象.run()启动线程</span></span><br><span class="line"><span class="comment">//        t1.run();</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//需要重新创建一个对象再start</span></span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如下的操作仍然是在main线程中执行的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +<span class="string">&quot;:&quot;</span>+ i + <span class="string">&quot;********main()*********&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果（因为线程由操作系统和cpu调度，多次运行结果不同）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">6</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">8</span></span><br><span class="line">main:<span class="number">0</span>********main()*********</span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">2</span></span><br><span class="line">main:<span class="number">2</span>********main()*********</span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">4</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">6</span></span><br><span class="line">Thread-<span class="number">0</span>:<span class="number">8</span></span><br><span class="line">main:<span class="number">4</span>********main()*********</span><br><span class="line">main:<span class="number">6</span>********main()*********</span><br><span class="line">main:<span class="number">8</span>********main()*********</span><br></pre></td></tr></table></figure>


<h2 id="2-创建线程的方式二：实现Runnable接口的方式"><a href="#2-创建线程的方式二：实现Runnable接口的方式" class="headerlink" title="2.创建线程的方式二：实现Runnable接口的方式"></a>2.创建线程的方式二：实现Runnable接口的方式</h2><p>使用方法：</p>
<ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()，启动线程  </li>
<li>实现Runnable和继承Thread方式的对比：<br>开发中：优先选择：实现Runnable接口的方式  </li>
</ol>
<p>原因：</p>
<ol>
<li>实现接口的方式没有类的单继承性的局限性<ol start="2">
<li>实现的方式更适合来处理多个线程共享数据的情况。  </li>
</ol>
</li>
</ol>
<ul>
<li>例子</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        MThread m = <span class="keyword">new</span> MThread();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(m,<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//再启动一个线程，遍历10以内偶数</span></span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(m,<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">线程二:<span class="number">0</span></span><br><span class="line">线程二:<span class="number">2</span></span><br><span class="line">线程二:<span class="number">4</span></span><br><span class="line">线程二:<span class="number">6</span></span><br><span class="line">线程一:<span class="number">0</span></span><br><span class="line">线程二:<span class="number">8</span></span><br><span class="line">线程一:<span class="number">2</span></span><br><span class="line">线程一:<span class="number">4</span></span><br><span class="line">线程一:<span class="number">6</span></span><br><span class="line">线程一:<span class="number">8</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建线程的方式三：实现Callable接口的方式-—-jdk5-0新增"><a href="#3-创建线程的方式三：实现Callable接口的方式-—-jdk5-0新增" class="headerlink" title="3.创建线程的方式三：实现Callable接口的方式 —- jdk5.0新增"></a>3.创建线程的方式三：实现Callable接口的方式 —- jdk5.0新增</h2><p>使用方法<br> 1.创建一个实现Callable接口的实现类<br> 2.重写call方法，将此线程需要执行的操作声明在call（）中<br> 3.创建Callable接口实现类的对象<br> 4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象<br> 5.将FutureTask的对象作为参数传入Thread类的构造器中，创建Thread对象，并调用start（）方法。<br> 6.还可以使用FutureTask对象的get()方法获取Callable中的call方法的返回值，不需要返回值的话，在重写的call（）方法里返回null即可</p>
<p>  如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</p>
<ol>
<li>call()方法是可以有返回值的。</li>
<li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li>
<li>Callable是支持泛型的  </li>
</ol>
<p>例子：创建一个以实现Callable方式的线程，内部计算1到100的所有偶数的和  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//2.重写call方法，将此线程需要执行的操作声明在call（）中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadNew</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        NumThread n = <span class="keyword">new</span> NumThread();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为参数传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask(n);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传入Thread类的构造器中，创建Thread对象，并调用start（）方法。</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中的call方法的返回值</span></span><br><span class="line">            <span class="comment">//get方法返回值即为futureTask构造器参数Callable实现类重写的call（）方法的返回值</span></span><br><span class="line">            Integer res = futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为&quot;</span>+res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果为：总和为2550</span></span><br></pre></td></tr></table></figure>

<h2 id="创建线程池的方式之四：创建线程池Executor"><a href="#创建线程池的方式之四：创建线程池Executor" class="headerlink" title="创建线程池的方式之四：创建线程池Executor"></a>创建线程池的方式之四：创建线程池Executor</h2><p>好处：<br>1.提高响应速度（减少了创建新线程的时间）<br>2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）<br>3.便于线程管理<br>corePoolSize：核心池的大小<br>maximumPoolSize：最大线程数<br>keepAliveTime：线程没任务时最多保持多长时间后会终止</p>
<p>主要有三种 Executor：</p>
<p>CachedThreadPool：一个任务创建一个线程；<br>FixedThreadPool：所有任务只能使用固定大小的线程；<br>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立MyRunnable类实现Runnable并在run()内添加需要的业务逻辑即可，这里省略</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="线程的生命周期和优先级"><a href="#线程的生命周期和优先级" class="headerlink" title="线程的生命周期和优先级"></a>线程的生命周期和优先级</h1><p>生命周期：<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jYW1vLmdpdGh1YnVzZXJjb250ZW50LmNvbS9iMDJiNjU0Mzk3YjE3YTE5OWFhMDI3MjdiNmVkNjVkZjBkZDRlZTE5LzY4NzQ3NDcwNzMzYTJmMmY2OTZkNjcyZDYyNmM2ZjY3MmU2MzczNjQ2ZTY5NmQ2NzJlNjM2ZTJmMzIzMDMxMzgzMTMwMzMzMTMxMzAzNTM2MzIzNzM0MzMzNzJlNzA2ZTY3M2Y3ODJkNmY3MzczMmQ3MDcyNmY2MzY1NzM3MzNkNjk2ZDYxNjc2NTJmNzc2MTc0NjU3MjZkNjE3MjZiMmM3NDc5NzA2NTVmNWE2ZDQ2NzU1YTMzNzA2ZjVhNTczNTZlNjE0NzU2NzA2NDQ3NmIyYzczNjg2MTY0NmY3NzVmMzEzMDJjNzQ2NTc4NzQ1ZjYxNDg1MjMwNjM0ODRkMzY0Yzc5Mzk2OTYyNDczOTZlNGM2ZDRlN2E1YTQ3MzQ3NTYyNmQ1NjMwNGMzMzcwNmY2MjMzNTUzNTRkNmE0MTMzNGY0NDU5N2E0ZDU0NDkzZDJjNzM2OTdhNjU1ZjMxMzYyYzYzNmY2YzZmNzI1ZjQ2NDY0NjQ2NDY0NjJjNzQ1ZjM3MzA?x-oss-process=image/format,png" alt="线程的状态转换"><br>状态</p>
<ul>
<li>new（新建）</li>
<li>runnnable（就绪）</li>
<li>blocked（阻塞）</li>
<li>waiting（等待）</li>
<li>time waiting （定时等待）</li>
<li>terminated（终止)  </li>
</ul>
<p>线程状态流程如下：</p>
<ul>
<li>线程创建后，进入 new 状态</li>
<li>调用 start 方法，进入 runnable 状态</li>
<li>JVM 按照线程优先级及时间分片等执行 runnable 状态的线程。开始执行时，执行run()方法并进入 running 状态</li>
<li>如果线程执行 sleep、wait、join，或者进入 IO 阻塞等。进入 wait 或者 blocked 状态</li>
<li>线程执行完毕后，线程被线程队列移除。最后为 terminated 状态          </li>
</ul>
<h1 id="线程的同步方法"><a href="#线程的同步方法" class="headerlink" title="线程的同步方法"></a>线程的同步方法</h1><h2 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h2><p>优点：线程安全但是效率较低<br>注意：同步监视器必须是独一无二的唯一对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">   <span class="comment">//需要被同步的代码...  </span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>非常经典的例子：卖票。<br>创建三个窗口卖票，总票数为10张，使用实现Runnable接口的方式。<br>若不加同步：卖票过程中，可能出现重票、错票的线程安全问题。<br>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来。<br>这里就用同步代码块来实现。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window1 w = <span class="keyword">new</span> Window1();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，票号为&quot;</span>+tickets);</span><br><span class="line">                    tickets--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行结果：没有重票，错票的情况。</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为10</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为9</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为8</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为7</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为6</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为5</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为4</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为3</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为2</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为1</span></span><br></pre></td></tr></table></figure>




<h2 id="方式二：声明同步方法"><a href="#方式二：声明同步方法" class="headerlink" title="方式二：声明同步方法"></a>方式二：声明同步方法</h2><p>在需要同步的操作共享资源的方法上添加synchronized关键字<br>同样是卖票的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Window3 w = <span class="keyword">new</span> Window3();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(w);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口一&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口二&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//同步监视器：this</span></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;卖票，票号为&quot;</span>+tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//窗口一卖票，票号为10</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为9</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为8</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为7</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为6</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为5</span></span><br><span class="line"><span class="comment">//窗口一卖票，票号为4</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为3</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为2</span></span><br><span class="line"><span class="comment">//窗口三卖票，票号为1</span></span><br></pre></td></tr></table></figure>


<h2 id="方式三：JUC的lock工具"><a href="#方式三：JUC的lock工具" class="headerlink" title="方式三：JUC的lock工具"></a>方式三：JUC的lock工具</h2><p>主要学习的是java.util.concurrent.locks.ReentrantLock<br>使用方式：进入操作共享数据逻辑之前，使用lock.lock()为线程加锁（假设实例化的ReentrantLcok对象名为lock），操作共享数据结束后释放锁：lock.unlock()，具体例子如下(这里使用了匿名内部类简化线程的创建)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    ticket.sale_ticket();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;一&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//lambda表达式写法</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ticket.sale_ticket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;二&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                ticket.sale_ticket();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;三&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tickets_number = <span class="number">10</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sale_ticket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(tickets_number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;卖第&quot;</span>+tickets_number--+<span class="string">&quot;张票，还剩&quot;</span> + tickets_number  + <span class="string">&quot;张票&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//线程一卖第10张票，还剩9张票</span></span><br><span class="line"><span class="comment">//线程一卖第9张票，还剩8张票</span></span><br><span class="line"><span class="comment">//线程一卖第8张票，还剩7张票</span></span><br><span class="line"><span class="comment">//线程一卖第7张票，还剩6张票</span></span><br><span class="line"><span class="comment">//线程二卖第6张票，还剩5张票</span></span><br><span class="line"><span class="comment">//线程一卖第5张票，还剩4张票</span></span><br><span class="line"><span class="comment">//线程三卖第4张票，还剩3张票</span></span><br><span class="line"><span class="comment">//线程一卖第3张票，还剩2张票</span></span><br><span class="line"><span class="comment">//线程三卖第2张票，还剩1张票</span></span><br><span class="line"><span class="comment">//线程一卖第1张票，还剩0张票</span></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-10/" class="post-title-link" itemprop="url">实现用户访问某个模块按权限拦截的方法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:06:25 / 修改时间：17:06:41" itemprop="dateCreated datePublished" datetime="2020-08-16T17:06:25+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="思路一：自定义注解-spring-intercepter方式"><a href="#思路一：自定义注解-spring-intercepter方式" class="headerlink" title="思路一：自定义注解+spring intercepter方式"></a>思路一：自定义注解+spring intercepter方式</h1><h2 id="1-定义一个Permission注解"><a href="#1-定义一个Permission注解" class="headerlink" title="1.定义一个Permission注解"></a>1.定义一个Permission注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Permission &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个注解一般会打到controller层的api方法上面。value代表了这个api需要的权限，也可以设计成Integer类型的代表需要的权限level，whatever，这个地方可以根据需要自己设计。</p>
<h2 id="2-编写intercepter"><a href="#2-编写intercepter" class="headerlink" title="2.编写intercepter"></a>2.编写intercepter</h2><p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span><span class="comment">//将拦截器注册到spring容器</span></span><br><span class="line"><span class="comment">//开始编写拦截器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//返回true即代表放过请求，返回false即代表拦截请求</span></span><br><span class="line">    <span class="comment">//根据Permission判断是否该放过请求</span></span><br><span class="line">    <span class="comment">//1.将handler强转为方法的handler</span></span><br><span class="line">    HandlerMethod handlerMethod = (HandlerMethod) handler;</span><br><span class="line">    <span class="comment">//2.获取这个api方法上面的注解</span></span><br><span class="line">    Permission permissionValue = handlerMethod.getMethod().getAnnotation(Permission.class);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//3.如果方法上没有Permission注解，代表这个api不需要权限，放过请求</span></span><br><span class="line">     <span class="keyword">if</span> (permissionValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">    <span class="comment">//4.如果获取到了非空的Permission注解，那么就判断是否有权限就好啦</span></span><br><span class="line">         <span class="keyword">if</span> (StringUtils.isNotBlank(permissionValue.value())) &#123;</span><br><span class="line">        <span class="comment">//把permissionValue.value()获取到后去判断权限，判断的方法可以自己设计，可以将考虑将各种权限信息设计到一个sql table里面！</span></span><br><span class="line">        <span class="keyword">if</span>(符合权限)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">//不符合权限，拦截，可以考虑抛个异常打个日志什么的，也可以考虑返给前端一个不符合权限的信息</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="思路二：用-Aspect切面实现拦截"><a href="#思路二：用-Aspect切面实现拦截" class="headerlink" title="思路二：用@Aspect切面实现拦截"></a>思路二：用@Aspect切面实现拦截</h1><p>//TODO</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-9/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记八：使用Redis实现分布式锁</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:05:32 / 修改时间：17:06:42" itemprop="dateCreated datePublished" datetime="2020-08-16T17:05:32+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>因为应用程序服务器有两台，所以如果仅仅在每台机器上面同步时不够的，因为获取到的不是同一把锁。</p>
<p>这里使用redis实现分布式锁</p>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>使用redis作为分布式锁要注意几点：</p>
<p>原理：在redis上面定义一个锁的key，每台应用程序服务器的下单请求先要去redis尝试创建一个锁的key，如果锁的key已经存在，那么说明其他线程已经进入，这个线程就阻塞。如果锁的key不存在，那么就说明锁是可以获取的状态，建立这个key从而获取锁。</p>
<p>注意事项一：产生异常情况如何保证锁的释放<br>答：利用try finally，try里面放下单流程，finally里面删除key，保证异常情况下也能释放锁。</p>
<p>注意事项二：服务器断电之后，锁一直存在怎么办？<br>答：设置过期时间，注意！redis的2.6之前的版本，设置锁的key、设置过期时间这两步操作不是原子性的！但是在2.6之后，可以用一行代码设置key并设置过期时间保证原子性。下面会介绍。</p>
<p>注意事项三：如何保证线程释放的是自己加上的锁？<br>答：加锁的key的时候，value设置为一个随机的uuid，等到删除key的时候，先判断缓存中value是不是这个uuid，如果是再释放。</p>
<p>注意事项四：程序执行时间过长，超过了key的过期时间怎么办？<br>开一个守护线程，先休眠，然后不断去判断当前线程是否还有持有锁，如果持有而且超时时间到，就给他“续命”，加上一段时间，直到线程自己删掉key释放锁。</p>
<h1 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h1><p>因为我的redis只有一台，如果redis也部署了主从，那么无法完全保证可靠性。因为分布式锁只会去验证主redis的加锁情况。而不会去验证从redis的key的情况。<br>但是zookeeper是有全部主从分布式锁的验证的，所以zookeeper比较能保证安全，但是相对于redis的实现方式效率较低。</p>
<p>redis实现的方式可以使用redisson框架直接实现</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>这里以减库存为例，方式超卖现象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">decreaseStock</span><span class="params">(Integer itemId, Integer amount)</span> <span class="keyword">throws</span> BusinessException </span>&#123;</span><br><span class="line">       <span class="comment">//int affectedRow = itemStockDOMapper.decreaseStock(itemId, amount);</span></span><br><span class="line">       <span class="comment">//result是代表执行完扣减库存操作之后的结果（还剩多少）</span></span><br><span class="line">       String lockValue = UUID.randomUUID().toString();</span><br><span class="line">       Boolean lockSuccess = redisTemplate.opsForValue().setIfAbsent(<span class="string">&quot;lockKey&quot;</span>, lockValue, <span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">       <span class="keyword">if</span>(lockSuccess)&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> result = redisTemplate.opsForValue().increment(<span class="string">&quot;kill_item_stock&quot;</span>+itemId, amount.intValue()*-<span class="number">1</span>);</span><br><span class="line">               <span class="keyword">if</span>(result &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                   <span class="comment">//更新库存成功</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                   <span class="comment">//更新库存失败</span></span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span>(redisTemplate.opsForValue().get(<span class="string">&quot;lockKey&quot;</span>).equals(lockValue))&#123;</span><br><span class="line">                   redisTemplate.delete(<span class="string">&quot;lockKey&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-8/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记七：nginx lua脚本实战</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:04:27 / 修改时间：17:05:10" itemprop="dateCreated datePublished" datetime="2020-08-16T17:04:27+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、nginx为什么高性能"><a href="#一、nginx为什么高性能" class="headerlink" title="一、nginx为什么高性能"></a>一、nginx为什么高性能</h1><h2 id="epoll多路复用"><a href="#epoll多路复用" class="headerlink" title="epoll多路复用"></a>epoll多路复用</h2><p>1.传统模型：基于缓冲区的传输<br>首先，假设这里有两台主机进行通信<br>client —– server<br>当client要向server传输数据的时候:数据不会直截了当地发到server处，而是先进行一个socket.write操作，并将要发送的数据包放到<strong>缓冲区</strong>中。<br>如果有一个数据包要发送，这时候缓冲器被占满了，那么tcp/ip会先将缓冲区里面的数据全部传输完成，才能让新的数据包进入缓冲区，然后再进入服务器。这样的操作效率不够高</p>
<p>2.linux select模型：变更触发轮询查找<br>select多路复用是server阻塞自己的同时监听多个客户端的连接，一旦有连接发生变化，那么就唤醒自己，循环遍历100个连接，找到发生变化的一个或者多个，执行read操作。缺陷：遍历的效率很低，并且有1024的数量上限</p>
<p>3.epoll多路复用模型：根据回调函数唤醒自己<br>同样，server阻塞自己同时监听多个客户端的连接。并且设置回调函数。若发生变化直接唤醒自己执行回调函数。</p>
<h2 id="master-worker进程模型"><a href="#master-worker进程模型" class="headerlink" title="master-worker进程模型"></a>master-worker进程模型</h2><p>启动nginx之后，会产生一个nginx的master进程，这个master可以产生多个worker进程，通过ps -ef | grep nginx可以看到：nginx启动了两种进程，一个是master process，一个worker process，并且可以发现master是worker的父进程。也就是说master进程可以管理一切worker进程中的内存，堆栈，函数……<br>而worker进程就是真正的处理多个客户端连接的一个进程，也就是客户端的请求是由worker进程去连接和管理的，而在并发情景下，nginx设置了<strong>内存中的锁</strong>，worker进程抢占锁的速度就会很快。并且每个worker进程是<strong>单线程的</strong>，进程的内部没有任何多线程的阻塞所以效率很高。</p>
<h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><p>1.协程是比线程更小的一个概念，一个线程可以有多个协程，协程之间的切换不是cpu管理的，而是在<strong>内存中切换</strong>，切换开销非常小。<br>2.协程遇到阻塞归还执行权给其他协程，代码自动同步，无需手动处理，无需加锁。</p>
<h1 id="二、开始优化"><a href="#二、开始优化" class="headerlink" title="二、开始优化"></a>二、开始优化</h1><p>1.第一尝试了配置nginx的proxy cache，第一次拿到热点数据之后将数据存储在nginx服务器上，下一次就从nginx获取，这样反而变慢了，tps在1200左右，这是因为<strong>nginx的proxy cache不是在内存中的，而是在磁盘中的！</strong>，所以他的性能反而不如再去tomcat服务器的内存里面获取快一些。</p>
<p>2.第二次尝试编写lua脚本,配置shared dictionary<br>nginx的shared dictionary，顾名思义就是共享字典，他是所有worker进程可见的，并且具有lru淘汰策略，最重要的是它将数据存储在内存中。</p>
<p>配置shared dictionary：</p>
<ul>
<li>打开nginx.conf<br>添加以下内容</li>
<li>*lua_shared_dict my_cache 128m;**<br>这一行的作用是给shared dictionary分配内存大小</li>
</ul>
<p>location处添加：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /luaitem/get&#123;</span><br><span class="line">    default_type <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">    content_by_lua_file = ../lua/itemshareddic.lua;</span><br></pre></td></tr></table></figure>



<ul>
<li>进入nginx的lua文件夹，编写itemshareddic.lua</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> get_from_cache(key)</span><br><span class="line">    <span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">    <span class="built_in">local</span> value = cache_ngx:get(key)</span><br><span class="line">    <span class="built_in">return</span> value</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> set_to_cache(key, value,exptime)</span><br><span class="line">    <span class="keyword">if</span> not exptime <span class="keyword">then</span></span><br><span class="line">        exptime = 0</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">local</span> cache_ngx = ngx.shared.my_cache</span><br><span class="line">    <span class="built_in">local</span> succ,err,forcible = cache_ngx:<span class="built_in">set</span>(key,value,exptime)</span><br><span class="line">    <span class="built_in">return</span> succ</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> id = args[<span class="string">&quot;id&quot;</span>]</span><br><span class="line"><span class="built_in">local</span> item_model = get_from_cache(<span class="string">&quot;item_&quot;</span>..id)</span><br><span class="line"><span class="keyword">if</span>(item_model == nil) <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">local</span> resp = ngx.location.capture(<span class="string">&quot;/item/get?id=&quot;</span>..id)</span><br><span class="line">    item_model = resp.body</span><br><span class="line">    set_to_cache(<span class="string">&quot;item_&quot;</span>..id,item_model,1*60)</span><br><span class="line">end</span><br><span class="line">ngx.say(item_model)</span><br></pre></td></tr></table></figure>

<h1 id="三、继续优化"><a href="#三、继续优化" class="headerlink" title="三、继续优化"></a>三、继续优化</h1><p>上面的优化是非常吃内存的，最大的缺陷更新不方便，所以这里继续配置openresty 的 redis支持，即将nginx服务器连接到redis数据库上面，可以只读不写。若redis没有对应的数据，那么就回到应用程序服务器上面去获取并存入redis，那么下一次ajax请求到达nginx服务器处，就直接从redis上面进行读的操作。甚至可以直接设立一个slave的redis，只负责读操作。</p>
<p>进入nginx服务器，打开lua文件夹，新建一个itemredis.lua</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> args = ngx.req.get_uri_args()</span><br><span class="line"><span class="built_in">local</span> id = args[<span class="string">&quot;id&quot;</span>]</span><br><span class="line"><span class="built_in">local</span> redis = require <span class="string">&quot;resty.redis&quot;</span></span><br><span class="line"><span class="built_in">local</span> cache = redis:new()</span><br><span class="line"><span class="built_in">local</span> ok,err = cache:connect(<span class="string">&quot;redis服务器的ip&quot;</span>,端口号)</span><br><span class="line"><span class="built_in">local</span> item_model = cache:get(<span class="string">&quot;item_&quot;</span>..id)</span><br><span class="line"><span class="keyword">if</span> item_model == ngx.null or item_model == nil <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">local</span> resp = ngx.location.capture(<span class="string">&quot;/item/get?id=&quot;</span>..id)</span><br><span class="line">    item_model = resp.body</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.say(item_model)</span><br></pre></td></tr></table></figure>

<p>打开nginx.conf<br>将上一个步骤中配置的location从itemshareddic.lua改为itemredis.lua<br>重启nginx服务即可</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-7/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记六：商品详情信息缓存策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:03:45 / 修改时间：17:04:22" itemprop="dateCreated datePublished" datetime="2020-08-16T17:03:45+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="一、商品详情页面缓存"><a href="#一、商品详情页面缓存" class="headerlink" title="一、商品详情页面缓存"></a>一、商品详情页面缓存</h1><p>商品详情页面存入redis缓存中<br>获取商品详情controller接口方法更改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据商品详情页的id到redis内获取,实现这个功能需要序列化itembo以及itembo内部聚合的killbo</span></span><br><span class="line">            itemBO = (ItemBO) redisTemplate.opsForValue().get(<span class="string">&quot;item_&quot;</span> + id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//若redis内不存在对应的itembo，则访问下游的service,去数据库取</span></span><br><span class="line">            <span class="keyword">if</span>(itemBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//只进一次service获取mysql数据库数据</span></span><br><span class="line">                itemBO = itemService.getItemById(id);</span><br><span class="line">                <span class="comment">//存到redis，并且存到redis内，设置上过期时间10分钟，第二次刷新之后的十分钟都从redis获取</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">&quot;item_&quot;</span>+id, itemBO);</span><br><span class="line">                redisTemplate.expire(<span class="string">&quot;item_&quot;</span>+id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>修改key - value的序列化方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span></span>&#123;</span><br><span class="line">        RedisTemplate redisTemplate = <span class="keyword">new</span> RedisTemplate();</span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="comment">//首先解决key的序列化方式，最简单的string即可</span></span><br><span class="line">        StringRedisSerializer stringRedisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解决value的序列化方式</span></span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">        simpleModule.addSerializer(DateTime.class, <span class="keyword">new</span> JodaDateTimeJsonSerializer());</span><br><span class="line">        simpleModule.addDeserializer(DateTime.class, <span class="keyword">new</span> JodaDateTimeJsonDeserializer());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使缓存包含类的信息        </span></span><br><span class="line">        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line"></span><br><span class="line">        objectMapper.registerModule(simpleModule);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);</span><br><span class="line">        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写datetime格式数据的序列化和反序列化方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JodaDateTimeJsonSerializer</span>  <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">DateTime</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        jsonGenerator.writeString(dateTime.toString(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JodaDateTimeJsonDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">DateTime</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">deserialize</span><span class="params">(JsonParser jsonParser, DeserializationContext deserializationContext)</span> <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line">        String dateString = jsonParser.readValueAs(String.class);</span><br><span class="line">        DateTimeFormatter formatter = DateTimeFormat.forPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> DateTime.parse(dateString, formatter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署，压测：<br>cpu-H<br>redis占用2%左右<br>平均响应时间300ms左右<br>tps最高2000+</p>
<h1 id="二、使用guava设计多级缓存策略"><a href="#二、使用guava设计多级缓存策略" class="headerlink" title="二、使用guava设计多级缓存策略"></a>二、使用guava设计多级缓存策略</h1><p>其实设计这个步骤的初衷是将商品模型直接存储在jvm中在一段时间内持久保存，首先考虑的是将商品模型做成一个HashMap，并让这个HashMap进行商品详情的缓存。但是这样做首先会有多线程的问题，不支持并发读写的问题。若改用ConcurentHashMap是基于段的方式加锁，在写锁加上去之后，会对读的性能有很大影响，并且还要考虑失效时间和淘汰机制这些复杂的内容，所以单纯的ConcurentHashMap非常复杂。<br>所以这里选用谷歌的guava cache来实现热点数据的缓存。</p>
<p>1.导入guava cache依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--guava将热点数据存入jvm内存中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.写CommonCache接口和实现类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//封装本地缓存操作类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取方法</span></span><br><span class="line">    <span class="function">Object <span class="title">getCommonCache</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String, Object&gt; commonCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//commonCache设置的方法是一串设置方法的实现，最后.build()来创建commonCache</span></span><br><span class="line">        commonCache = CacheBuilder.newBuilder()</span><br><span class="line">                <span class="comment">//设置缓存容器的初始容量为10</span></span><br><span class="line">                .initialCapacity(<span class="number">10</span>)</span><br><span class="line">                <span class="comment">//设置缓存中最大存储100个key，超过100个之后会按照lru的策略移除缓存项</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)</span><br><span class="line">                <span class="comment">//设置写缓存之后多少秒过期</span></span><br><span class="line">                .expireAfterWrite(<span class="number">60</span>, TimeUnit.SECONDS).build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        commonCache.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在获取商品详情的controller接口再次更改获取model的方式<br>1.先从guava cache取，没有去redis取，再没有去service层（mysql）取。<br>2.若redis有，存入guava cache；若service有，存入redis，存入guava cache。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品详情页的浏览，（浏览功能一般用get请求）</span></span><br><span class="line">   <span class="meta">@GetMapping(value = &quot;/get&quot;)</span></span><br><span class="line">   <span class="meta">@ResponseBody</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(<span class="meta">@RequestParam(name = &quot;id&quot;)</span> Integer id)</span></span>&#123;</span><br><span class="line">       ItemBO itemBO = <span class="keyword">null</span>;</span><br><span class="line">       <span class="comment">//先取本地缓存</span></span><br><span class="line">       itemBO = (ItemBO) cacheService.getCommonCache(<span class="string">&quot;item_&quot;</span>+id);</span><br><span class="line">       <span class="comment">//本地缓存不存在，去redis找</span></span><br><span class="line">       <span class="keyword">if</span>(itemBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="comment">//根据商品详情页的id到redis内获取,实现这个功能需要序列化itembo以及itembo内部聚合的killbo</span></span><br><span class="line">           itemBO = (ItemBO) redisTemplate.opsForValue().get(<span class="string">&quot;item_&quot;</span> + id);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//若redis内不存在对应的itembo，则访问下游的service,去数据库取</span></span><br><span class="line">           <span class="keyword">if</span>(itemBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">               itemBO = itemService.getItemById(id);</span><br><span class="line">               <span class="comment">//存到redis，并且存到redis内，加上过期时间</span></span><br><span class="line">               redisTemplate.opsForValue().set(<span class="string">&quot;item_&quot;</span>+id, itemBO);</span><br><span class="line">               redisTemplate.expire(<span class="string">&quot;item_&quot;</span>+id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//从redis获取完之后，将数据保存到本地缓存之中,填充本地缓存</span></span><br><span class="line">           cacheService.setCommonCache(<span class="string">&quot;item_&quot;</span>+id, itemBO);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>总结：<br>guava cache可以方便的控制cache的大小和存活时间，而且可以配置淘汰策略，并且线程安全。</p>
<p>压测：<br>这次效果出现了飞跃式的增长：<br>cpu-H 数据库服务器的cpu基本无压力<br>响应时间：150ms左右<br>tps:3200左右</p>
<p>不用再经过反向代理服务器–&gt;tomcat服务器–&gt;redis/mysql这个繁杂的过程，直接去tomcat服务器一层的jvm里面取数据，减少了一段网络开销。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-6/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记五：分布式扩展之后的分布式session问题解决</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:02:35 / 修改时间：17:03:47" itemprop="dateCreated datePublished" datetime="2020-08-16T17:02:35+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="项目添加redis的session依赖"><a href="#项目添加redis的session依赖" class="headerlink" title="项目添加redis的session依赖"></a>项目添加redis的session依赖</h1><p>将分布式session存储在redis内：<br>打开项目的pom.xml，导入springboot对reids的依赖</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>添加如下依赖之后，可以增加一个配置类配置session存活时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)</span><span class="comment">//session存活一小时</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据库服务器安装redis4-0-1"><a href="#数据库服务器安装redis4-0-1" class="headerlink" title="数据库服务器安装redis4.0.1"></a>数据库服务器安装redis4.0.1</h1><p>我这里数据库服务器只有一台，而应用程序服务器是多台的，所以会出现分布式的session获取不到的问题，这里将redis安装到唯一的数据库服务器中。</p>
<p>官网下载redis-4.0.1.tar.gz，放到服务器：<br>执行：<br>chmod - R 777 redis-4.0.1.tar.gz<br>tar -xvzf redis-4.0.1.tar.gz<br>cd redis-4.0.1<br>make<br>make install<br>cd src<br>./redis-server &amp;<br>./redis-cli<br>安装并启动redis</p>
<h1 id="本地部署测试"><a href="#本地部署测试" class="headerlink" title="本地部署测试"></a>本地部署测试</h1><p>修改application.properties:<br>增加redis配置</p>
<p>#配置springboot对redis的依赖<br>spring.redis.host=127.0.0.1 # 这里之后还要修改<br>spring.redis.port=6379<br>spring.redis.database=10<br>#spring.redis.password=</p>
<p>#设置jedis连接池<br>spring.redis.jedis.pool.max-active=50<br>spring.redis.jedis.pool.min-idle=20</p>
<p>将用户登录的session模型类实现Serializable使redis可以序列化</p>
<p>之后测试登录：<br>登录成功</p>
<p>踩坑：<br>但是……坑爹的来了，测试获取验证码失败。<br>一步一步debug：发现redis内有数据，key也是正确的，<strong>但是获取却一直为null。</strong><br>因为我的验证码的获取和用户输入是两个不同的页面，所以为了安全起见，session默认会被获取为null。<br><strong>查阅资料得出，如果满足以下几点，session可能获取为null。</strong></p>
<ul>
<li>使用了springboot2.x，并且前后端资源是跨域的。</li>
<li>获取session的请求接口是post方式发送的</li>
<li>存储session和取得session是不同的两个页面。</li>
</ul>
<p>满足以上三点，session的获取就会为null；<br>解决方案，编写配置类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSessionConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringSessionConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CookieSerializer <span class="title">httpSessionIdResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultCookieSerializer cookieSerializer = <span class="keyword">new</span> DefaultCookieSerializer();</span><br><span class="line">        <span class="comment">// 取消仅限同一站点设置</span></span><br><span class="line">        cookieSerializer.setSameSite(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> cookieSerializer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功完成session跨页获取<br>至此为止，分布式session的问题被解决。不会出现用户登录失效的问题。</p>
<h1 id="token方式替代基于cookie传递sessionId"><a href="#token方式替代基于cookie传递sessionId" class="headerlink" title="token方式替代基于cookie传递sessionId"></a>token方式替代基于cookie传递sessionId</h1><p>项目代码中修改，将传统session方式替代。这样的好处是可以使用多个平台的兼容性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//生成登录凭证token，每个用户不重复的uuid</span></span><br><span class="line">        String uuidToken = UUID.randomUUID().toString();</span><br><span class="line">        uuidToken = uuidToken.replace(<span class="string">&quot;-&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//建立token和登陆之后用户模型之间的联系</span></span><br><span class="line">        redisTemplate.opsForValue().set(uuidToken, userBO);</span><br><span class="line">        <span class="comment">//设置超时时间一个小时</span></span><br><span class="line">        redisTemplate.expire(uuidToken,<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"><span class="comment">//        //将登录凭证加入到用户登陆成功的session</span></span><br><span class="line"><span class="comment">//        this.httpServletRequest.getSession().setAttribute(&quot;IS_LOGIN&quot;, true);</span></span><br><span class="line"><span class="comment">//        this.httpServletRequest.getSession().setAttribute(&quot;LOGIN_USER&quot;, userBO);</span></span><br><span class="line">        <span class="comment">//下发token</span></span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(uuidToken);</span><br></pre></td></tr></table></figure>

<p>前端判断登录成功之后存储token的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = data.data;</span><br><span class="line"><span class="comment">//html5新出的token方式localStorage，比cookie session安全且没有容量限制</span></span><br><span class="line"><span class="built_in">window</span>.localStorage[<span class="string">&quot;token&quot;</span>]=token;</span><br></pre></td></tr></table></figure>

<p>需要验证用户登录信息时，验证token是否存在：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = <span class="built_in">window</span>.localStorage[<span class="string">&quot;token&quot;</span>];</span><br><span class="line">            <span class="keyword">if</span>(token == <span class="literal">null</span>)&#123;</span><br><span class="line">                alert(<span class="string">&quot;没有登录，不能下单！&quot;</span>);</span><br><span class="line">                <span class="built_in">window</span>.location.href=<span class="string">&quot;login.html&quot;</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>后端负责验证token信息是否正确，并从token获取用户模型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String token = httpServletRequest.getParameterMap().get(<span class="string">&quot;token&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN,<span class="string">&quot;用户还未登录，不能下单&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取用户登录信息</span></span><br><span class="line">        UserBO userBO = (UserBO) redisTemplate.opsForValue().get(token);</span><br><span class="line">        <span class="keyword">if</span>(userBO == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EmBusinessError.USER_NOT_LOGIN,<span class="string">&quot;用户还未登录，不能下单&quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>最后别忘了将token放到ajax请求的url中（参数拼上?token=”+token）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//登录成功之后，将用户模型存入前台的localStorage</span><br><span class="line">            var token = data.data;</span><br><span class="line">//html5新出的token方式localStorage，比cookie session安全且没有容量限制</span><br><span class="line">            window.localStorage[&quot;token&quot;]=token;</span><br><span class="line">//....................................................................</span><br><span class="line">            var token = window.localStorage[&quot;token&quot;];//从前台localStorage获取token</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type: &quot;POST&quot;,</span><br><span class="line">                url: &quot;http://&quot;+g_host+&quot;/order/createorder?token=&quot;+token,</span><br><span class="line">                contentType: &quot;application/x-www-form-urlencoded&quot;,</span><br></pre></td></tr></table></figure>

<p>本地调试成功之后，部署到云端的数据库服务器中，因为我这里暂时还没有主从服务器，只有一台数据库服务器，所以把redis安装在了mysql数据库服务器中，两者共用一台服务器。</p>
<p>将两台应用程序服务器的application.properties都修改，增加如下的配置：<br>spring.redis.host=数据库服务器的私网ip。<br>之后重新启动两个应用程序jar包，调试，成功。</p>
<h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p>这篇文章主要解决的问题是：<br>用户登录信息的session经过分布式扩展之后可能获取不到的问题，从基于cookie传递sessionID的方式转化为基于token传输类似于sessionID的形式，并且使session迁移至公共的redis数据库中。</p>
<p>解决方式：<br>通过redis集中式缓存sessionID。并通过redisTemplate.opsForValue().set(uuidToken, userBO);实现session的存取。<br>UserBO userBO = (UserBO) redisTemplate.opsForValue().get(token);实现session的获取。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-5/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记四：nginx反向代理优化，分布式扩展</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:02:12 / 修改时间：17:03:35" itemprop="dateCreated datePublished" datetime="2020-08-16T17:02:12+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>首先我们需要思考上一个章节并发上不去的原因。发现在并发环境下mysql数据库的压力始终很大，一台服务器上面不仅仅要跑java的jar包程序，还要承受高并发访问数据库的压力。这样的压力都在同一台服务器上显然存在缺陷。所以我们可以购买多台服务器。</p>
<p>一台专门用来部署项目的数据库。<br>两台或多台用来部署项目jar包。<br>一台用来配置部署nginx反向代理。</p>
<p>首先这里购买4台服务器，两台跑java，一台部署数据库，一台部署nginx。</p>
<p>部署前准备：<br>将原来的  //var/www项目文件夹传输至另两台需要部署jar包的服务器中,原来的服务器就用来部署mysql数据库。</p>
<p>使用scp：<br><strong>scp  -r   //var/www  root@目标服务器ip地址:/var</strong>，然后输入密码即可。<br>这里如果购买的多台服务器都是阿里云的同一地区的服务器，用私有ip进行传输，因为阿里云同一地区的服务器是内网互通的，互相传输快的飞起。</p>
<p>分别将www内的项目文件传输完成之后。准备在两台服务器上面配置数据库连接并启动。</p>
<h1 id="应用程序服务器（两台）"><a href="#应用程序服务器（两台）" class="headerlink" title="应用程序服务器（两台）"></a>应用程序服务器（两台）</h1><p>先在两台应用程序服务器上rpm安装jdk，之前的笔记中有操作流程这里不再赘述。<br>切换到项目www/seckill目录准备启动项目。在把jar包跑起来之前，先要将接收到的配置文件修改一下，因为，项目中的application.properties文件默认的datasource.url是localhost:3306。如果这样启动起来，是找不到数据库的，因为应用程序服务器并不是用来部署数据库的，所以，我们打开外挂的配置文件修改datasource：<br>vim application.properties.<br>添加下面一行配置：<br><strong>spring.datasource.url=jdbc:mysql://数据库服务器的内网ip:3306/seckillboot?serverTimezone=GMT%2B8</strong><br>数据库服务器的内网地址即刚刚传输项目的服务器，<strong>必须用内网ip保证数据库访问速度</strong>。</p>
<p>配置好DataSource之后，在启动项目之前，测试能否连接上数据库的服务器：<br><strong>yum install telnet</strong><br><strong>telnet  数据库服务器ip  3306</strong><br>结果发现，远程数据库拒绝了连接。<br>这时候我们要去数据库服务器配置mysql的远程连接权限（见第二部分）。<br>配置好之后再次telnet ip:3306测试连接，提示输入数据库密码即可连接，这里就不连了，直接 <strong>./deploy.sh &amp;</strong> 启动项目即可。<br>启动项目之后，访问 <strong>项目服务器公有ip/可以访问数据库的路径，我的是ip/item/get?id=9，可以显示出从数据库获取的item数据，表示部署成功（两台服务器操作相同）</strong></p>
<h1 id="数据库服务器"><a href="#数据库服务器" class="headerlink" title="数据库服务器"></a>数据库服务器</h1><h2 id="配置其他服务器连接数据库的权限"><a href="#配置其他服务器连接数据库的权限" class="headerlink" title="配置其他服务器连接数据库的权限"></a>配置其他服务器连接数据库的权限</h2><p>只要知道数据库的root的密码就可以有全部数据库的全部权限,最后刷新权限，无需重启数据库，可以这样配置。<br><strong>mysql -uroot -p密码<br>grant all privileges on *.* to root@’%’ identified by ‘root’;</strong><br><strong>flush privileges;</strong></p>
<p>这时，到应用程序服务器上就可以访问到数据库服务器的数据库。<br>下面是nginx反向代理服务器的配置。</p>
<h1 id="nginx反向代理服务器"><a href="#nginx反向代理服务器" class="headerlink" title="nginx反向代理服务器"></a>nginx反向代理服务器</h1><p>在部署nginx的服务器上安装openresty：<br>1.下载openresty并上传到部署nginx的服务器。<br>2.chomd -R 777授予权限，<strong>tar -xvzf  包名</strong>  安装解压。<br>3.cd 解压后的openresty目录。<br>4.   执行 <strong>./configure</strong>（需要先yum install gcc）<br>5. <strong>make</strong>编译完成之后，<strong>make install</strong><br>6. <strong>cd //user/local/openresty</strong>进入openresty目录。<br>7. 在nginx目录下，cd ls直到出现conf  html  logs  sbin四个文件夹。在这个目录下执行<strong>sbin/nginx -c conf/nginx.conf 启动nginx</strong>，配置文件的主要参数：<br>location节点path：指定url映射key<br>location节点内容：root指定location path后对应的根路径，index指定默认的访问页。<br><strong>重启nginx的命令</strong>为：<strong>sbin/nginx -s reload</strong></p>
<p>8.启动nginx之后访问服务器ip会显示openresty的成功页。<br>至此nginx安装部署完成。</p>
<h1 id="将前端资源部署到nginx上。"><a href="#将前端资源部署到nginx上。" class="headerlink" title="将前端资源部署到nginx上。"></a>将前端资源部署到nginx上。</h1><p>1.将本地的html文件上传到服务器的：/usr/local/openresty/nginx/html路径下，并命名为resources文件夹。<br>2.vim编辑/usr/local/openresty/nginx/conf路径下的nginx.conf文件修改前端路由配置。<br>3.修改如下区域的配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">location /resources/&#123;</span><br><span class="line">    <span class="built_in">alias</span>  /usr/<span class="built_in">local</span>/openresty/nginx/html/resources/;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即如果输入的路径地址包括了/resources下，那么就会自动去/usr/local/openresty/nginx/html/resources/这个alias路径下寻找资源，并且将对应名字的html资源拼接在后面，也就是说alias起到一个替代的作用</p>
<h1 id="开始配置nginx反向代理"><a href="#开始配置nginx反向代理" class="headerlink" title="开始配置nginx反向代理"></a>开始配置nginx反向代理</h1><p>将静态资源部署到了nginx服务器之后，我们还要做以下操作配置反向代理以完成请求的路由：</p>
<ul>
<li>设置upstream server</li>
<li>设置动态请求location为proxy pass路径。</li>
</ul>
<p>继续修改nginx.conf（这部分非常关键）：</p>
<h2 id="配置upstream："><a href="#配置upstream：" class="headerlink" title="配置upstream："></a>配置upstream：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">#gzip  on;</span></span><br><span class="line">   upstream seckill_server&#123;</span><br><span class="line">server 应用程序服务器1的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">server 应用程序服务器2的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>以上面代码为例，seckill_server是这个upstream的别名，下面要用到，ip和端口号指明了应用程序服务器的tomcat的路由地址，weight指明了nginx反向代理服务器配置的轮询是一比一的，也就是一半的请求轮询的路由到应用程序服务器1，一半到应用程序服务器2。（如果应用程序服务器在本机的话，要注意nginx和tomcat的端口号不能冲突，比如本机的tomcat端口号是8080，那么直接server localhost:8080;即可）</p>
<h2 id="配置动态资源的location"><a href="#配置动态资源的location" class="headerlink" title="配置动态资源的location"></a>配置动态资源的location</h2><p>在上一次配置的静态资源的location的下面新增一个配置：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">        proxy_pass http://seckill_server; <span class="comment"># 刚刚配置好的别名</span></span><br><span class="line">        proxy_set_header Host <span class="variable">$http_host</span>:<span class="variable">$proxy_port</span>;    </span><br><span class="line">        proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;<span class="comment"># 真正的地址是远程的</span></span><br><span class="line">        proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>; <span class="comment"># nginx作为代理服务器转发请求</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>配置的意思就是如果请求路径不包括resources，那么所有请求都会发送到seckill_server<br>之后sbin/nginx -s reload重启nginx，可以t进入logs目录tail -f error.log查看是否报错。</p>
<p>==2020.2.23更新这里留下的坑==<br>nginx配置upstream的时候名字<strong>不能包含 _ 下划线</strong>！这里我配置的<strong>seckill_server</strong>就完美的踩到了这个坑…这里就不修改了，如果配置的话要注意一下，tomcat8及以上都会有这个问题。</p>
<h1 id="分布式扩展之后的压测"><a href="#分布式扩展之后的压测" class="headerlink" title="分布式扩展之后的压测"></a>分布式扩展之后的压测</h1><p>先将服务器的带宽扩展以减少带宽造成的网络延迟误差。<br>先压测之前的单机服务器，开启1000个线程循环30次，5秒之内启动。<br>结果：<br>average：460ms左右<br>tps：1500左右<br>top -H-&gt;%Cpu(s)：最高达到了80us<br>load average:1.3<br>可以发现单机服务器的负载达到了在这个并发环境下近乎达到了极限。</p>
<p>压测分布式扩展之后的服务器：<br>压测nginx代理服务器的代理地址，并观察数据库服务器的top -H：<br>结果：<br>average：450ms左右<br>tps：==1750==左右<br>top -H-&gt;%Cpu(s)：==2us==<br>load average:0.5<br>可以发现分布式扩展之后数据库服务器的压力明显减小。可以说解决了单机容量的瓶颈问题。</p>
<h1 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h1><h2 id="配置nginx和应用服务器长连接"><a href="#配置nginx和应用服务器长连接" class="headerlink" title="配置nginx和应用服务器长连接"></a>配置nginx和应用服务器长连接</h2><p>我们的数据库服务器是通过druid连接池实现连接的，也就是数据库服务器默认是长连接的方式，但是nginx默认是和后端服务器默认是短连接的方式，有建立连接和释放连接的过程，虽然局域网内的服务器短连接耗时很少，但是还是需要优化。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">#gzip  on;</span></span><br><span class="line">   upstream seckill_server&#123;</span><br><span class="line">server 应用程序服务器1的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">server 应用程序服务器2的私有ip:服务器的tomcat端口号 weight=1;</span><br><span class="line">keepalive 30;<span class="comment"># 开启keepalive模式，设置keepalive为30秒</span></span><br><span class="line">   &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
<p>修改http协议版本以支持keepalive：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">     proxy_pass http://seckill_server;</span><br><span class="line">     <span class="comment">#proxy_set_header Host $http_host:$proxy_port;      </span></span><br><span class="line">     proxy_set_header X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">     proxy_set_header X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">     proxy_http_version 1.1;</span><br><span class="line">     proxy_set_header Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再次压测结果：<br>average：==350ms==左右<br>tps：1750左右（变化不大）<br>top -H-&gt;%Cpu(s)：2us     （变化不大）<br>load average:0.5（变化不大）</p>
<p>可以看出，配置了nginx和后端服务器的长连接之后，平均的请求时长降低了100ms，减少了网络不断建立和释放连接的耗时。</p>
<h1 id="留下的坑"><a href="#留下的坑" class="headerlink" title="留下的坑"></a>留下的坑</h1><p>没有配置分布式的session，因为我的项目的用户登录的信息存储在tomcat的session内，如果nginx通过反向代理路由到了一台没有session的服务区上，那么用户将无法完成需要登录(get session)的操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-4/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记三：jemeter工具对项目接口进行并发压测，初步优化。</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:01:00 / 修改时间：17:03:37" itemprop="dateCreated datePublished" datetime="2020-08-16T17:01:00+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="下载并启动jemeter"><a href="#下载并启动jemeter" class="headerlink" title="下载并启动jemeter"></a>下载并启动jemeter</h1><p>下载好jemeter5并解压之后，可以先打开jemeter目录下的bin\jmeter.properties文件设置语言：在#language=en下面新加一行添加：<strong>language=zh_CN</strong> 设置显示中文。然后直接运行jemeter.bat可以直接在windows端打开压测工具。</p>
<h1 id="jemeter压测配置"><a href="#jemeter压测配置" class="headerlink" title="jemeter压测配置"></a>jemeter压测配置</h1><p>jemeter压测主要需要以下配置：</p>
<ul>
<li>线程组：启动多个并发的线程发送接口请求，用来测试服务端压力，可以配置线程数，循环次数等等。</li>
<li>Http请求：线程组发送http请求，需要指定服务器名称或ip，端口号和压测路径。并且打开keepAlive来忽略因为长连接因素造成的误差。（tips：服务器名称可以通过driver/etc/hosts文件来指定，指定的格式为 <strong>云服务器ip地址  服务器名称</strong>）这样在访问的时候就可以直接输入服务器名称，而不用去记ip。</li>
<li>查看结果树：http请求发送之后，查看http返回的结果。</li>
<li>聚合报告：记录了线程组进行压测的结果的各项指标。包括tps和qps。</li>
</ul>
<h1 id="开始压测"><a href="#开始压测" class="headerlink" title="开始压测"></a>开始压测</h1><p>jemeter内先保存压测的信息，然后点击绿色运行按钮进行压测。然后可以查看结果树和聚合报告：<br>聚合报告内各个标签意义：</p>
<ul>
<li>average：平均响应时间</li>
<li>median：中位数的响应时间</li>
<li>90% line：有百分之90的请求是在这个结果的时间之内返回的，<strong>95% line</strong>， 99% line类似。</li>
<li>min：最短的返回时间</li>
<li>max：最长的返回时间</li>
<li><strong>throughput(tps)：每秒处理事务数，每秒收发包的数量:比如在10秒内成功处理500个并发请求，那么tps就是50。</strong></li>
</ul>
<p>聚合报告中：<strong>比较重要的是95%线和tps。</strong></p>
<p>准备压测：<br>1.ps -ef | grep java 查看java的进程编号，我这里是21079.</p>
<p>2.使用pstree 21079，查看有多少个线程数量</p>
<p>3.top -H 查看服务器的各项实时指标：<br>%cpus ： us为用户占用的， sy为系统占用的，一般观察us<br>load average：代表的收发的压力</p>
<p>4.打开jemeter，设置线程数，这里我设置的线程数为100个，每个线程循环请求10次，共1000次请求，100个线程在10秒内启动。</p>
<p>5.结果，us最高达到了38.8%，没有出错的线程，还不够，再加！<br>设置线程数500个。一边运行一边查看聚合报告，这次qps最高能达到250多。查看top -H发现mysql的cpu占用非常高。因为我测试的接口压力基本都来自数据库。还是不太够，可以直接加多一些，看看出错的原因在哪里。</p>
<p>6.这次我设置线程数为5000，循环100次。这次顶不住了。。。<br>查看 pstree -p 21079 | wc -l  ——&gt;59<br>最高才能走59个并发。所以肯定是有问题的，下面是优化。</p>
<h1 id="初步优化"><a href="#初步优化" class="headerlink" title="初步优化"></a>初步优化</h1><p>打开项目的springboot内嵌的tomcat的配置文件。<br>查看可能与并发多线程相关的参数：</p>
<p><strong>server.tomcat.accept-count : 默认是100。这个参数是当tomcat的线程被全部占满之后最大的等待队列的大小。即当等待队列达到100个的时候，再进来的请求线程会被拒绝掉。<br>server.tomcat.min-spare-threads ：默认是10。这个是tomcat应对突发的流量入口的时候的默认启动的线程数，可以理解为最小线程数。<br>server.tomcat.max-connections： 默认10000，可接受的最大连接数。<br>server.tomcat.max-threads：默认200。tomcat最大支持的工作线程数。</strong></p>
<p>这样的配置下：连接超过10000之后会出现拒绝连接的情况。请求的线程数超过200+100（等待队列+最大线程数）之后拒绝处理（刚才启动了5000个线程，大量的线程会失败）。</p>
<p>所以我们<strong>第一步的优化就是修改tomcat的并发相关的配置</strong>。不做这个配置任何其他优化都收效甚微。</p>
<p>打开挂载的springboot配置文件application.properties<br>修改上面四个当中的三个配置：<br><strong>server.tomcat.accept-count=800<br>server.tomcat.max-threads=500<br>server.tomcat.min-spare-threads=100</strong></p>
<p><strong>主要将最小线程数和最大线程数调高，并把等待队列大小扩容。<br>但是：<br>1.最大线程数不能无限大，太大的话会花费巨大的时间在cpu调度，一般4核8g的服务器会设置为1000以下，这里我是4g的就设置为500。<br>2.等待队列长度也不能过大，等待队列相当于线程的缓冲池，太大会很耗内存，出入队操作也耗费cpu</strong></p>
<p>设置好之后，重启项目 ./deploy.sh &amp;<br>将并发数调到一个合理的范围：大概200-500之间，循环次数50次。<br>发现延时300ms左右，tps200左右。无错误。</p>
<p>还有比较重要的keepalive方面的参数，springboot并没有对外开放，需要自己写WebServerFactoryCustomize &lt;ConfigurableWebServerFactory&gt;<br>的实现类来配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当spring容器内没有TomcatEmbeddedServletContainerFactory这个bean的时候，会把bean加载进来。</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用对应工厂类提供的接口定制化我们的tomcat connector</span></span><br><span class="line">        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line">                <span class="comment">//定制化keepAliveTimeOut,30秒，30秒内没有请求，服务端才会断开keepalive连接</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line">                <span class="comment">//当客户端发送超过10000个请求，则自动断开keepalive连接</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，tomcat的参数优化基本完成，tps仍然不高，后续优化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://jiazx.top/2020/08/16/%E9%A1%B9%E7%9B%AE-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Stephen Jia">
      <meta itemprop="description" content="Try Everything......">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/16/%E9%A1%B9%E7%9B%AE-3/" class="post-title-link" itemprop="url">阿里云个人服务器搭建项目笔记二：springboot项目打包部署到服务器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-08-16 17:00:06 / 修改时间：17:03:39" itemprop="dateCreated datePublished" datetime="2020-08-16T17:00:06+08:00">2020-08-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="maven打包："><a href="#maven打包：" class="headerlink" title="maven打包："></a>maven打包：</h1><p>进入项目根目录：<br>踩坑1：<br><strong>mvn clean package</strong>，运行target中的jar包<br>java -jar seckill_boot-1.0-SNAPSHOT.jar 报错：<br>jar包中没有主清单属性。<br>原因是这种方式打包的jar没有入口main，也没有各种依赖jar包。<br>需要在pom.xml中导入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">     &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">     &lt;configuration&gt;</span><br><span class="line">       &lt;source&gt;1.8&lt;/source&gt;</span><br><span class="line">       &lt;target&gt;1.8&lt;/target&gt;</span><br><span class="line">     &lt;/configuration&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br><span class="line">   &lt;plugin&gt;</span><br><span class="line">     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">   &lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<p>踩坑2：<br>导入了依赖，发现打包之后运行仍然找不到主清单属性，原因在于：<br><strong>不能将上面的依赖直接写在其他plugin标签后面！<br>要将上面的依赖另写一个&lt;plugins&gt;&lt;/plugins&gt;大标签内。</strong><br>重新mvn clean package即可。</p>
<h1 id="上传jar包到服务器："><a href="#上传jar包到服务器：" class="headerlink" title="上传jar包到服务器："></a>上传jar包到服务器：</h1><p>1.同样使用xftp上传jar包到tmp目录<br>2.在//var文件夹下mkdir新建 www 文件夹<br>3.新建seckill文件夹<br>4.将jar包移动到seckill文件夹下并重命名为seckill.jar<br><strong>mv //tmp/seckill_boot-1.0-SNAPSHOT.jar ./seckill.jar</strong><br>5.chmod -R 777 *赋予seckill.jar权限，然后java -jar启动<br>6.将阿里云服务器处的80/9999端口打开，开放给0.0.0.0/0<br>7.输入服务器 ip:端口号 确认访问是否成功。</p>
<h1 id="编写外挂配置文件启动"><a href="#编写外挂配置文件启动" class="headerlink" title="编写外挂配置文件启动"></a>编写外挂配置文件启动</h1><p>如果我们要修改项目配置文件的话，那么我们每次都要从本地修改配置文件，打包上传重新部署，这样效率很低。<br>由于jar包内的配置每次都要修改，我们可以配置一个脚本使其覆盖掉jar包内的配置文件的某些属性，达到只改一次就能起效果的状态。</p>
<p>如何使用外挂配置文件的方式启动呢？<br>1.jar包的同级目录下创建application.properties。编辑需要覆盖的属性，这里以server.port=80端口为例测试。<br>2.重新以外挂配置文件启动项目：命令如下：<br><strong>java -jar seckill.jar –spring.config.addition-location=/var/www/seckill/application.properties</strong></p>
<h1 id="编写deploy脚本启动"><a href="#编写deploy脚本启动" class="headerlink" title="编写deploy脚本启动"></a>编写deploy脚本启动</h1><p>在seckill下编写deploy.sh文件:<br><strong>nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar seckill.jar –spring.config.addition-location=/var/www/seckill/applic<br>ation.properties</strong></p>
<p>参数解释：<br>nohup：目的是使java程序不会被中止。<br>-Xms400m -Xmx400m：jvm最小最大都为400m，防止内存不稳定。<br>-XX:NewSize=200m -XX:MaxNewSize=200m： 新生代的最小大小和最大大小，均为200m。</p>
<p>使用 <strong>./deploy.sh &amp;</strong> 命令执行脚本，这个时候终端是看不到输出的。<br>观察输出的方法：使用 <strong>tail -200f nohup.out</strong>命令观察控制台的输出。<br>进入之后就可以实时观察项目运行效果。<br>此时即使ctrl+c退出，也不会影响java程序的运行。</p>
<p>至此为止，完成了使用脚本将项目启动并且不随意退出的效果。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Stephen Jia"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Stephen Jia</p>
  <div class="site-description" itemprop="description">Try Everything......</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Younjzxx" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Younjzxx" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Stephen Jia</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
